import z from "fraction.js";
z.prototype.sam = function() {
  return this.floor();
};
z.prototype.nextSam = function() {
  return this.sam().add(1);
};
z.prototype.wholeCycle = function() {
  return new x(this.sam(), this.nextSam());
};
z.prototype.cyclePos = function() {
  return this.sub(this.sam());
};
z.prototype.lt = function(e) {
  return this.compare(e) < 0;
};
z.prototype.gt = function(e) {
  return this.compare(e) > 0;
};
z.prototype.lte = function(e) {
  return this.compare(e) <= 0;
};
z.prototype.gte = function(e) {
  return this.compare(e) >= 0;
};
z.prototype.eq = function(e) {
  return this.compare(e) == 0;
};
z.prototype.max = function(e) {
  return this.gt(e) ? this : e;
};
z.prototype.min = function(e) {
  return this.lt(e) ? this : e;
};
z.prototype.show = function() {
  return this.s * this.n + "/" + this.d;
};
z.prototype.or = function(e) {
  return this.eq(0) ? e : this;
};
const b = (e) => z(e), Ae = (...e) => e.reduce((t, n) => t.gcd(n), b(1));
b._original = z;
class x {
  constructor(t, n) {
    this.begin = b(t), this.end = b(n);
  }
  get spanCycles() {
    const t = [];
    var n = this.begin;
    const r = this.end, o = r.sam();
    if (n.equals(r))
      return [new x(n, r)];
    for (; r.gt(n); ) {
      if (n.sam().equals(o)) {
        t.push(new x(n, this.end));
        break;
      }
      const s = n.nextSam();
      t.push(new x(n, s)), n = s;
    }
    return t;
  }
  get duration() {
    return this.end.sub(this.begin);
  }
  cycleArc() {
    const t = this.begin.cyclePos(), n = t.add(this.duration);
    return new x(t, n);
  }
  withTime(t) {
    return new x(t(this.begin), t(this.end));
  }
  withEnd(t) {
    return new x(this.begin, t(this.end));
  }
  withCycle(t) {
    const n = this.begin.sam(), r = n.add(t(this.begin.sub(n))), o = n.add(t(this.end.sub(n)));
    return new x(r, o);
  }
  intersection(t) {
    const n = this.begin.max(t.begin), r = this.end.min(t.end);
    if (!n.gt(r) && !(n.equals(r) && (n.equals(this.end) && this.begin.lt(this.end) || n.equals(t.end) && t.begin.lt(t.end))))
      return new x(n, r);
  }
  intersection_e(t) {
    const n = this.intersection(t);
    if (n == null)
      throw "TimeSpans do not intersect";
    return n;
  }
  midpoint() {
    return this.begin.add(this.duration.div(b(2)));
  }
  equals(t) {
    return this.begin.equals(t.begin) && this.end.equals(t.end);
  }
  show() {
    return this.begin.show() + " → " + this.end.show();
  }
}
class T {
  /*
        Event class, representing a value active during the timespan
        'part'. This might be a fragment of an event, in which case the
        timespan will be smaller than the 'whole' timespan, otherwise the
        two timespans will be the same. The 'part' must never extend outside of the
        'whole'. If the event represents a continuously changing value
        then the whole will be returned as None, in which case the given
        value will have been sampled from the point halfway between the
        start and end of the 'part' timespan.
        The context is to store a list of source code locations causing the event.
  
        The word 'Event' is more or less a reserved word in javascript, hence this
        class is named called 'Hap'.
        */
  constructor(t, n, r, o = {}, s = !1) {
    this.whole = t, this.part = n, this.value = r, this.context = o, this.stateful = s, s && console.assert(typeof this.value == "function", "Stateful values must be functions");
  }
  get duration() {
    return this.whole.end.sub(this.whole.begin).mul(typeof this.value?.clip == "number" ? this.value?.clip : 1);
  }
  get endClipped() {
    return this.whole.begin.add(this.duration);
  }
  wholeOrPart() {
    return this.whole ? this.whole : this.part;
  }
  withSpan(t) {
    const n = this.whole ? t(this.whole) : void 0;
    return new T(n, t(this.part), this.value, this.context);
  }
  withValue(t) {
    return new T(this.whole, this.part, t(this.value), this.context);
  }
  hasOnset() {
    return this.whole != null && this.whole.begin.equals(this.part.begin);
  }
  resolveState(t) {
    if (this.stateful && this.hasOnset()) {
      console.log("stateful");
      const n = this.value, [r, o] = n(t);
      return [r, new T(this.whole, this.part, o, this.context, !1)];
    }
    return [t, this];
  }
  spanEquals(t) {
    return this.whole == null && t.whole == null || this.whole.equals(t.whole);
  }
  equals(t) {
    return this.spanEquals(t) && this.part.equals(t.part) && // TODO would == be better ??
    this.value === t.value;
  }
  show(t = !1) {
    const n = typeof this.value == "object" ? t ? JSON.stringify(this.value).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(this.value) : this.value;
    var r = "";
    if (this.whole == null)
      r = "~" + this.part.show;
    else {
      var o = this.whole.begin.equals(this.part.begin) && this.whole.end.equals(this.part.end);
      this.whole.begin.equals(this.part.begin) || (r = this.whole.begin.show() + " ⇜ "), o || (r += "("), r += this.part.show(), o || (r += ")"), this.whole.end.equals(this.part.end) || (r += " ⇝ " + this.whole.end.show());
    }
    return "[ " + r + " | " + n + " ]";
  }
  showWhole(t = !1) {
    return `${this.whole == null ? "~" : this.whole.show()}: ${typeof this.value == "object" ? t ? JSON.stringify(this.value).slice(1, -1).replaceAll('"', "").replaceAll(",", " ") : JSON.stringify(this.value) : this.value}`;
  }
  combineContext(t) {
    const n = this;
    return { ...n.context, ...t.context, locations: (n.context.locations || []).concat(t.context.locations || []) };
  }
  setContext(t) {
    return new T(this.whole, this.part, this.value, t);
  }
  ensureObjectValue() {
    if (typeof this.value != "object")
      throw new Error(
        `expected hap.value to be an object, but got "${this.value}". Hint: append .note() or .s() to the end`,
        "error"
      );
  }
}
class et {
  constructor(t, n = {}) {
    this.span = t, this.controls = n;
  }
  // Returns new State with different span
  setSpan(t) {
    return new et(t, this.controls);
  }
  withSpan(t) {
    return this.setSpan(t(this.span));
  }
  // Returns new State with different controls
  setControls(t) {
    return new et(this.span, t);
  }
}
const Dt = "strudel.log";
function H(e, t, n = {}) {
  console.log(`%c${e}`, "background-color: black;color:white;border-radius:15px"), typeof document < "u" && typeof CustomEvent < "u" && document.dispatchEvent(
    new CustomEvent(Dt, {
      detail: {
        message: e,
        type: t,
        data: n
      }
    })
  );
}
H.key = Dt;
const Jn = (e) => /^[a-gA-G][#bs]*[0-9]$/.test(e), kt = (e) => /^[a-gA-G][#bsf]*[0-9]?$/.test(e), ke = (e) => {
  if (typeof e != "string")
    return [];
  const [t, n = "", r] = e.match(/^([a-gA-G])([#bsf]*)([0-9]*)$/)?.slice(1) || [];
  return t ? [t, n, r ? Number(r) : void 0] : [];
}, Ce = { c: 0, d: 2, e: 4, f: 5, g: 7, a: 9, b: 11 }, Se = { "#": 1, b: -1, s: 1, f: -1 }, ht = (e, t = 3) => {
  const [n, r, o = t] = ke(e);
  if (!n)
    throw new Error('not a note: "' + e + '"');
  const s = Ce[n.toLowerCase()], i = r?.split("").reduce((a, u) => a + Se[u], 0) || 0;
  return (Number(o) + 1) * 12 + s + i;
}, ft = (e) => Math.pow(2, (e - 69) / 12) * 440, Gt = (e) => 12 * Math.log(e / 440) / Math.LN2 + 69, Wn = (e, t) => {
  if (typeof e != "object")
    throw new Error("valueToMidi: expected object value");
  let { freq: n, note: r } = e;
  if (typeof n == "number")
    return Gt(n);
  if (typeof r == "string")
    return ht(r);
  if (typeof r == "number")
    return r;
  if (!t)
    throw new Error("valueToMidi: expected freq or note to be set");
  return t;
}, xe = (e) => ft(typeof e == "number" ? e : ht(e)), Be = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], In = (e) => {
  const t = Math.floor(e / 12) - 1;
  return Be[e % 12] + t;
}, gt = (e, t) => (e % t + t) % t;
function Te(e, t = 0) {
  return isNaN(Number(e)) ? (H(`"${e}" is not a number, falling back to ${t}`, "warning"), t) : e;
}
const Rn = (e, t) => gt(Math.round(Te(e ?? 0, 0)), t), Vn = (e) => {
  let { value: t, context: n } = e, r = t;
  if (typeof r == "object" && !Array.isArray(r) && (r = r.note || r.n || r.value, r === void 0))
    throw new Error(`cannot find a playable note for ${JSON.stringify(t)}`);
  if (typeof r == "number" && n.type !== "frequency")
    r = ft(e.value);
  else if (typeof r == "number" && n.type === "frequency")
    r = e.value;
  else if (typeof r != "string" || !kt(r))
    throw new Error("not a note: " + JSON.stringify(r));
  return r;
}, Dn = (e) => {
  let { value: t, context: n } = e;
  if (typeof t == "object")
    return t.freq ? t.freq : xe(t.note || t.n || t.value);
  if (typeof t == "number" && n.type !== "frequency")
    t = ft(e.value);
  else if (typeof t == "string" && kt(t))
    t = ft(ht(e.value));
  else if (typeof t != "number")
    throw new Error("not a note or frequency: " + t);
  return t;
}, Oe = (e, t) => e.slice(t).concat(e.slice(0, t)), Ee = (...e) => e.reduce(
  (t, n) => (...r) => t(n(...r)),
  (t) => t
), Gn = (...e) => Ee(...e.reverse()), ze = (e) => e.filter((t) => t != null), Y = (e) => [].concat(...e), lt = (e) => e, Qn = (e, t) => e, Qt = (e, t) => Array.from({ length: t - e + 1 }, (n, r) => r + e);
function _(e, t, n = e.length) {
  const r = function o(...s) {
    if (s.length >= n)
      return e.apply(this, s);
    {
      const i = function(...a) {
        return o.apply(this, s.concat(a));
      };
      return t && t(i, s), i;
    }
  };
  return t && t(r, []), r;
}
function Ut(e) {
  const t = Number(e);
  if (!isNaN(t))
    return t;
  if (kt(e))
    return ht(e);
  throw new Error(`cannot parse as numeral: "${e}"`);
}
function Kt(e, t) {
  return (...n) => e(...n.map(t));
}
function J(e) {
  return Kt(e, Ut);
}
function Pe(e) {
  const t = Number(e);
  if (!isNaN(t))
    return t;
  const n = {
    pi: Math.PI,
    w: 1,
    h: 0.5,
    q: 0.25,
    e: 0.125,
    s: 0.0625,
    t: 1 / 3,
    f: 0.2,
    x: 1 / 6
  }[e];
  if (typeof n < "u")
    return n;
  throw new Error(`cannot parse as fractional: "${e}"`);
}
const Un = (e) => Kt(e, Pe), Xt = function(e, t) {
  return [t.slice(0, e), t.slice(e)];
}, Yt = (e, t, n) => t.map((r, o) => e(r, n[o])), Me = (e, t, n) => Math.min(Math.max(e, t), n), je = ["Do", "Reb", "Re", "Mib", "Mi", "Fa", "Solb", "Sol", "Lab", "La", "Sib", "Si"], Fe = [
  "Sa",
  "Re",
  "Ga",
  "Ma",
  "Pa",
  "Dha",
  "Ni"
], Ne = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Hb", "H"], $e = [
  "Ni",
  "Pab",
  "Pa",
  "Voub",
  "Vou",
  "Ga",
  "Dib",
  "Di",
  "Keb",
  "Ke",
  "Zob",
  "Zo"
], He = [
  "I",
  "Ro",
  "Ha",
  "Ni",
  "Ho",
  "He",
  "To"
], Le = ["C", "Db", "D", "Eb", "E", "F", "Gb", "G", "Ab", "A", "Bb", "B"], Kn = (e, t = "letters") => {
  const r = (t === "solfeggio" ? je : t === "indian" ? Fe : t === "german" ? Ne : t === "byzantine" ? $e : t === "japanese" ? He : Le)[e % 12], o = Math.floor(e / 12) - 1;
  return r + o;
};
function Je(e) {
  const t = new TextEncoder().encode(e);
  return btoa(String.fromCharCode(...t));
}
function We(e) {
  const t = new Uint8Array(
    atob(e).split("").map((r) => r.charCodeAt(0))
  );
  return new TextDecoder().decode(t);
}
function Xn(e) {
  return encodeURIComponent(Je(e));
}
function Yn(e) {
  return We(decodeURIComponent(e));
}
function Ie(e, t) {
  return Array.isArray(e) ? e.map(t) : Object.fromEntries(Object.entries(e).map(([n, r], o) => [n, t(r, n, o)]));
}
function Re(e, t, n) {
  if (typeof t?.value == "number") {
    const o = Object.keys(e).filter((i) => typeof e[i] == "number"), s = Object.fromEntries(o.map((i) => [i, t.value]));
    t = Object.assign(t, s), delete t.value;
  }
  const r = Object.keys(e).filter((o) => Object.keys(t).includes(o));
  return Object.assign({}, e, t, Object.fromEntries(r.map((o) => [o, n(e[o], t[o])])));
}
_((e, t) => e * t);
_((e, t) => t.map(e));
function Ve(e, t = 60) {
  let n = 0, r = b(0), o = [""], s = "";
  for (; o[0].length < t; ) {
    const i = e.queryArc(n, n + 1), a = i.filter((f) => f.hasOnset()).map((f) => f.duration), u = Ae(...a), l = u.inverse();
    o = o.map((f) => f + "|"), s += "|";
    for (let f = 0; f < l; f++) {
      const [h, y] = [r, r.add(u)], m = i.filter((v) => v.whole.begin.lte(h) && v.whole.end.gte(y)), A = m.length - o.length;
      A > 0 && (o = o.concat(Array(A).fill(s))), o = o.map((v, q) => {
        const w = m[q];
        if (w) {
          const N = w.whole.begin.eq(h) ? "" + w.value : "-";
          return v + N;
        }
        return v + ".";
      }), s += ".", r = r.add(u);
    }
    n++;
  }
  return o.join(`
`);
}
let vt;
const Zn = (e) => vt = e;
class p {
  /**
   * Create a pattern. As an end user, you will most likely not create a Pattern directly.
   *
   * @param {function} query - The function that maps a `State` to an array of `Hap`.
   * @noAutocomplete
   */
  constructor(t) {
    this.query = t, this._Pattern = !0;
  }
  //////////////////////////////////////////////////////////////////////
  // Haskell-style functor, applicative and monadic operations
  /**
   * Returns a new pattern, with the function applied to the value of
   * each hap. It has the alias `fmap`.
   * @synonyms fmap
   * @param {Function} func to to apply to the value
   * @returns Pattern
   * @example
   * "0 1 2".withValue(v => v + 10).log()
   */
  withValue(t) {
    return new p((n) => this.query(n).map((r) => r.withValue(t)));
  }
  /**
   * see `withValue`
   * @noAutocomplete
   */
  fmap(t) {
    return this.withValue(t);
  }
  /**
   * Assumes 'this' is a pattern of functions, and given a function to
   * resolve wholes, applies a given pattern of values to that
   * pattern of functions.
   * @param {Function} whole_func
   * @param {Function} func
   * @noAutocomplete
   * @returns Pattern
   */
  appWhole(t, n) {
    const r = this, o = function(s) {
      const i = r.query(s), a = n.query(s), u = function(l, f) {
        const h = l.part.intersection(f.part);
        if (h != null)
          return new T(
            t(l.whole, f.whole),
            h,
            l.value(f.value),
            f.combineContext(l)
          );
      };
      return Y(
        i.map((l) => ze(a.map((f) => u(l, f))))
      );
    };
    return new p(o);
  }
  /**
   * When this method is called on a pattern of functions, it matches its haps
   * with those in the given pattern of values.  A new pattern is returned, with
   * each matching value applied to the corresponding function.
   *
   * In this `_appBoth` variant, where timespans of the function and value haps
   * are not the same but do intersect, the resulting hap has a timespan of the
   * intersection. This applies to both the part and the whole timespan.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appBoth(t) {
    const n = function(r, o) {
      if (!(r == null || o == null))
        return r.intersection_e(o);
    };
    return this.appWhole(n, t);
  }
  /**
   * As with `appBoth`, but the `whole` timespan is not the intersection,
   * but the timespan from the function of patterns that this method is called
   * on. In practice, this means that the pattern structure, including onsets,
   * are preserved from the pattern of functions (often referred to as the left
   * hand or inner pattern).
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appLeft(t) {
    const n = this, r = function(o) {
      const s = [];
      for (const i of n.query(o)) {
        const a = t.query(o.setSpan(i.wholeOrPart()));
        for (const u of a) {
          const l = i.whole, f = i.part.intersection(u.part);
          if (f) {
            const h = i.value(u.value), y = u.combineContext(i), m = new T(l, f, h, y);
            s.push(m);
          }
        }
      }
      return s;
    };
    return new p(r);
  }
  /**
   * As with `appLeft`, but `whole` timespans are instead taken from the
   * pattern of values, i.e. structure is preserved from the right hand/outer
   * pattern.
   * @param {Pattern} pat_val
   * @noAutocomplete
   * @returns Pattern
   */
  appRight(t) {
    const n = this, r = function(o) {
      const s = [];
      for (const i of t.query(o)) {
        const a = n.query(o.setSpan(i.wholeOrPart()));
        for (const u of a) {
          const l = i.whole, f = u.part.intersection(i.part);
          if (f) {
            const h = u.value(i.value), y = i.combineContext(u), m = new T(l, f, h, y);
            s.push(m);
          }
        }
      }
      return s;
    };
    return new p(r);
  }
  bindWhole(t, n) {
    const r = this, o = function(s) {
      const i = function(u, l) {
        return new T(
          t(u.whole, l.whole),
          l.part,
          l.value,
          Object.assign({}, u.context, l.context, {
            locations: (u.context.locations || []).concat(l.context.locations || [])
          })
        );
      }, a = function(u) {
        return n(u.value).query(s.setSpan(u.part)).map((l) => i(u, l));
      };
      return Y(r.query(s).map((u) => a(u)));
    };
    return new p(o);
  }
  bind(t) {
    const n = function(r, o) {
      if (!(r == null || o == null))
        return r.intersection_e(o);
    };
    return this.bindWhole(n, t);
  }
  join() {
    return this.bind(lt);
  }
  outerBind(t) {
    return this.bindWhole((n) => n, t);
  }
  outerJoin() {
    return this.outerBind(lt);
  }
  innerBind(t) {
    return this.bindWhole((n, r) => r, t);
  }
  innerJoin() {
    return this.innerBind(lt);
  }
  // Flatterns patterns of patterns, by retriggering/resetting inner patterns at onsets of outer pattern haps
  trigJoin(t = !1) {
    const n = this;
    return new p((r) => n.discreteOnly().query(r).map((o) => o.value.late(t ? o.whole.begin : o.whole.begin.cyclePos()).query(r).map(
      (s) => new T(
        // Supports continuous haps in the inner pattern
        s.whole ? s.whole.intersection(o.whole) : void 0,
        s.part.intersection(o.part),
        s.value
      ).setContext(o.combineContext(s))
    ).filter((s) => s.part)).flat());
  }
  trigzeroJoin() {
    return this.trigJoin(!0);
  }
  // Like the other joins above, joins a pattern of patterns of values, into a flatter
  // pattern of values. In this case it takes whole cycles of the inner pattern to fit each event
  // in the outer pattern.
  squeezeJoin() {
    const t = this;
    function n(r) {
      const o = t.discreteOnly().query(r);
      function s(a) {
        const l = a.value._focusSpan(a.wholeOrPart()).query(r.setSpan(a.part));
        function f(h, y) {
          let m;
          if (y.whole && h.whole && (m = y.whole.intersection(h.whole), !m))
            return;
          const A = y.part.intersection(h.part);
          if (!A)
            return;
          const v = y.combineContext(h);
          return new T(m, A, y.value, v);
        }
        return l.map((h) => f(a, h));
      }
      return Y(o.map(s)).filter((a) => a);
    }
    return new p(n);
  }
  squeezeBind(t) {
    return this.fmap(t).squeezeJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // Utility methods mainly for internal use
  /**
   * Query haps inside the given time span.
   *
   * @param {Fraction | number} begin from time
   * @param {Fraction | number} end to time
   * @returns Hap[]
   * @example
   * const pattern = sequence('a', ['b', 'c'])
   * const haps = pattern.queryArc(0, 1)
   * console.log(haps)
   * silence
   * @noAutocomplete
   */
  queryArc(t, n, r = {}) {
    try {
      return this.query(new et(new x(t, n), r));
    } catch (o) {
      return H(`[query]: ${o.message}`, "error"), [];
    }
  }
  /**
   * Returns a new pattern, with queries split at cycle boundaries. This makes
   * some calculations easier to express, as all haps are then constrained to
   * happen within a cycle.
   * @returns Pattern
   * @noAutocomplete
   */
  splitQueries() {
    const t = this, n = (r) => Y(r.span.spanCycles.map((o) => t.query(r.setSpan(o))));
    return new p(n);
  }
  /**
   * Returns a new pattern, where the given function is applied to the query
   * timespan before passing it to the original pattern.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQuerySpan(t) {
    return new p((n) => this.query(n.withSpan(t)));
  }
  withQuerySpanMaybe(t) {
    const n = this;
    return new p((r) => {
      const o = r.withSpan(t);
      return o.span ? n.query(o) : [];
    });
  }
  /**
   * As with `withQuerySpan`, but the function is applied to both the
   * begin and end time of the query timespan.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withQueryTime(t) {
    return new p((n) => this.query(n.withSpan((r) => r.withTime(t))));
  }
  /**
   * Similar to `withQuerySpan`, but the function is applied to the timespans
   * of all haps returned by pattern queries (both `part` timespans, and where
   * present, `whole` timespans).
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHapSpan(t) {
    return new p((n) => this.query(n).map((r) => r.withSpan(t)));
  }
  /**
   * As with `withHapSpan`, but the function is applied to both the
   * begin and end time of the hap timespans.
   * @param {Function} func the function to apply
   * @returns Pattern
   * @noAutocomplete
   */
  withHapTime(t) {
    return this.withHapSpan((n) => n.withTime(t));
  }
  /**
   * Returns a new pattern with the given function applied to the list of haps returned by every query.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHaps(t) {
    return new p((n) => t(this.query(n), n));
  }
  /**
   * As with `withHaps`, but applies the function to every hap, rather than every list of haps.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withHap(t) {
    return this.withHaps((n) => n.map(t));
  }
  /**
   * Returns a new pattern with the context field set to every hap set to the given value.
   * @param {*} context
   * @returns Pattern
   * @noAutocomplete
   */
  setContext(t) {
    return this.withHap((n) => n.setContext(t));
  }
  /**
   * Returns a new pattern with the given function applied to the context field of every hap.
   * @param {Function} func
   * @returns Pattern
   * @noAutocomplete
   */
  withContext(t) {
    return this.withHap((n) => n.setContext(t(n.context)));
  }
  /**
   * Returns a new pattern with the context field of every hap set to an empty object.
   * @returns Pattern
   * @noAutocomplete
   */
  stripContext() {
    return this.withHap((t) => t.setContext({}));
  }
  /**
   * Returns a new pattern with the given location information added to the
   * context of every hap.
   * @param {Number} start start offset
   * @param {Number} end end offset
   * @returns Pattern
   * @noAutocomplete
   */
  withLoc(t, n) {
    const r = {
      start: t,
      end: n
    };
    return this.withContext((o) => {
      const s = (o.locations || []).concat([r]);
      return { ...o, locations: s };
    });
  }
  /**
   * Returns a new Pattern, which only returns haps that meet the given test.
   * @param {Function} hap_test - a function which returns false for haps to be removed from the pattern
   * @returns Pattern
   * @noAutocomplete
   */
  filterHaps(t) {
    return new p((n) => this.query(n).filter(t));
  }
  /**
   * As with `filterHaps`, but the function is applied to values
   * inside haps.
   * @param {Function} value_test
   * @returns Pattern
   * @noAutocomplete
   */
  filterValues(t) {
    return new p((n) => this.query(n).filter((r) => t(r.value)));
  }
  /**
   * Returns a new pattern, with haps containing undefined values removed from
   * query results.
   * @returns Pattern
   * @noAutocomplete
   */
  removeUndefineds() {
    return this.filterValues((t) => t != null);
  }
  /**
   * Returns a new pattern, with all haps without onsets filtered out. A hap
   * with an onset is one with a `whole` timespan that begins at the same time
   * as its `part` timespan.
   * @returns Pattern
   * @noAutocomplete
   */
  onsetsOnly() {
    return this.filterHaps((t) => t.hasOnset());
  }
  /**
   * Returns a new pattern, with 'continuous' haps (those without 'whole'
   * timespans) removed from query results.
   * @returns Pattern
   * @noAutocomplete
   */
  discreteOnly() {
    return this.filterHaps((t) => t.whole);
  }
  /**
   * Combines adjacent haps with the same value and whole.  Only
   * intended for use in tests.
   * @noAutocomplete
   */
  defragmentHaps() {
    return this.discreteOnly().withHaps((n) => {
      const r = [];
      for (var o = 0; o < n.length; ++o) {
        for (var s = !0, i = n[o]; s; ) {
          const l = JSON.stringify(n[o].value);
          for (var a = !1, u = o + 1; u < n.length; u++) {
            const f = n[u];
            if (i.whole.equals(f.whole)) {
              if (i.part.begin.eq(f.part.end)) {
                if (l === JSON.stringify(f.value)) {
                  i = new T(i.whole, new x(f.part.begin, i.part.end), i.value), n.splice(u, 1), a = !0;
                  break;
                }
              } else if (f.part.begin.eq(i.part.end) && l == JSON.stringify(f.value)) {
                i = new T(i.whole, new x(i.part.begin, f.part.end), i.value), n.splice(u, 1), a = !0;
                break;
              }
            }
          }
          s = a;
        }
        r.push(i);
      }
      return r;
    });
  }
  /**
   * Queries the pattern for the first cycle, returning Haps. Mainly of use when
   * debugging a pattern.
   * @param {Boolean} with_context - set to true, otherwise the context field
   * will be stripped from the resulting haps.
   * @returns [Hap]
   * @noAutocomplete
   */
  firstCycle(t = !1) {
    var n = this;
    return t || (n = n.stripContext()), n.query(new et(new x(b(0), b(1))));
  }
  /**
   * Accessor for a list of values returned by querying the first cycle.
   * @noAutocomplete
   */
  get firstCycleValues() {
    return this.firstCycle().map((t) => t.value);
  }
  /**
   * More human-readable version of the `firstCycleValues` accessor.
   * @noAutocomplete
   */
  get showFirstCycle() {
    return this.firstCycle().map(
      (t) => `${t.value}: ${t.whole.begin.toFraction()} - ${t.whole.end.toFraction()}`
    );
  }
  /**
   * Returns a new pattern, which returns haps sorted in temporal order. Mainly
   * of use when comparing two patterns for equality, in tests.
   * @returns Pattern
   * @noAutocomplete
   */
  sortHapsByPart() {
    return this.withHaps(
      (t) => t.sort(
        (n, r) => n.part.begin.sub(r.part.begin).or(n.part.end.sub(r.part.end)).or(n.whole.begin.sub(r.whole.begin).or(n.whole.end.sub(r.whole.end)))
      )
    );
  }
  asNumber() {
    return this.fmap(Ut);
  }
  //////////////////////////////////////////////////////////////////////
  // Operators - see 'make composers' later..
  _opIn(t, n) {
    return this.fmap(n).appLeft(d(t));
  }
  _opOut(t, n) {
    return this.fmap(n).appRight(d(t));
  }
  _opMix(t, n) {
    return this.fmap(n).appBoth(d(t));
  }
  _opSqueeze(t, n) {
    const r = d(t);
    return this.fmap((o) => r.fmap((s) => n(o)(s))).squeezeJoin();
  }
  _opSqueezeOut(t, n) {
    const r = this;
    return d(t).fmap((s) => r.fmap((i) => n(i)(s))).squeezeJoin();
  }
  _opTrig(t, n) {
    return d(t).fmap((o) => this.fmap((s) => n(s)(o))).trigJoin();
  }
  _opTrigzero(t, n) {
    return d(t).fmap((o) => this.fmap((s) => n(s)(o))).trigzeroJoin();
  }
  //////////////////////////////////////////////////////////////////////
  // End-user methods.
  // Those beginning with an underscore (_) are 'patternified',
  // i.e. versions are created without the underscore, that are
  // magically transformed to accept patterns for all their arguments.
  //////////////////////////////////////////////////////////////////////
  // Methods without corresponding toplevel functions
  /**
   * Layers the result of the given function(s). Like `superimpose`, but without the original pattern:
   * @name layer
   * @memberof Pattern
   * @synonyms apply
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .layer(x=>x.add("0,2"))
   *   .scale('C minor').note()
   */
  layer(...t) {
    return M(...t.map((n) => n(this)));
  }
  /**
   * Superimposes the result of the given function(s) on top of the original pattern:
   * @name superimpose
   * @memberof Pattern
   * @returns Pattern
   * @example
   * "<0 2 4 6 ~ 4 ~ 2 0!3 ~!5>*8"
   *   .superimpose(x=>x.add(2))
   *   .scale('C minor').note()
   */
  superimpose(...t) {
    return this.stack(...t.map((n) => n(this)));
  }
  //////////////////////////////////////////////////////////////////////
  // Multi-pattern functions
  /**
   * Stacks the given pattern(s) to the current pattern.
   * @name stack
   * @memberof Pattern
   * @example
   * s("hh*4").stack(
   *   note("c4(5,8)")
   * )
   */
  stack(...t) {
    return M(this, ...t);
  }
  sequence(...t) {
    return R(this, ...t);
  }
  /**
   * Appends the given pattern(s) to the current pattern.
   * @name seq
   * @memberof Pattern
   * @synonyms sequence, fastcat
   * @example
   * s("hh*4").seq(
   *   note("c4(5,8)")
   * )
   */
  seq(...t) {
    return R(this, ...t);
  }
  /**
   * Appends the given pattern(s) to the next cycle.
   * @name cat
   * @memberof Pattern
   * @synonyms slowcat
   * @example
   * s("hh*4").cat(
   *   note("c4(5,8)")
   * )
   */
  cat(...t) {
    return ee(this, ...t);
  }
  fastcat(...t) {
    return K(this, ...t);
  }
  slowcat(...t) {
    return U(this, ...t);
  }
  //////////////////////////////////////////////////////////////////////
  // Context methods - ones that deal with metadata
  onTrigger(t, n = !0) {
    return this.withHap(
      (r) => r.setContext({
        ...r.context,
        onTrigger: (...o) => {
          r.context.onTrigger?.(...o), t(...o);
        },
        // if dominantTrigger is set to true, the default output (webaudio) will be disabled
        // when using multiple triggers, you cannot flip this flag to false again!
        // example: x.csound('CooLSynth').log() as well as x.log().csound('CooLSynth') should work the same
        dominantTrigger: r.context.dominantTrigger || n
      })
    );
  }
  log(t = (r, o) => `[hap] ${o.showWhole(!0)}`, n = (r, o) => ({ hap: o })) {
    return this.onTrigger((...r) => {
      H(t(...r), void 0, n(...r));
    }, !1);
  }
  logValues(t = lt) {
    return this.log((n, r) => t(r.value));
  }
  //////////////////////////////////////////////////////////////////////
  // Visualisation
  drawLine() {
    return console.log(Ve(this)), this;
  }
}
function De(e, t) {
  let n = [];
  return t.forEach((r) => {
    const o = n.findIndex(([s]) => e(r, s));
    o === -1 ? n.push([r]) : n[o].push(r);
  }), n;
}
const Ge = (e, t) => e.spanEquals(t);
p.prototype.collect = function() {
  return this.withHaps(
    (e) => De(Ge, e).map((t) => new T(t[0].whole, t[0].part, t, {}))
  );
};
p.prototype.arpWith = function(e) {
  return this.collect().fmap((t) => d(e(t))).innerJoin().withHap((t) => new T(t.whole, t.part, t.value.value, t.combineContext(t.value)));
};
p.prototype.arp = function(e) {
  return this.arpWith((t) => e.fmap((n) => t[n % t.length]));
};
function Qe(e, t, n) {
  function r(o) {
    return o instanceof Object && !(o instanceof Function);
  }
  return r(e) || r(t) ? (r(e) || (e = { value: e }), r(t) || (t = { value: t }), Re(e, t, n)) : n(e, t);
}
(function() {
  const e = {
    set: [(n, r) => r],
    keep: [(n) => n],
    keepif: [(n, r) => r ? n : void 0],
    // numerical functions
    /**
     *
     * Assumes a pattern of numbers. Adds the given number to each item in the pattern.
     * @name add
     * @memberof Pattern
     * @example
     * // Here, the triad 0, 2, 4 is shifted by different amounts
     * n("0 2 4".add("<0 3 4 0>")).scale("C:major")
     * // Without add, the equivalent would be:
     * // n("<[0 2 4] [3 5 7] [4 6 8] [0 2 4]>").scale("C:major")
     * @example
     * // You can also use add with notes:
     * note("c3 e3 g3".add("<0 5 7 0>"))
     * // Behind the scenes, the notes are converted to midi numbers:
     * // note("48 52 55".add("<0 5 7 0>"))
     */
    add: [J((n, r) => n + r)],
    // support string concatenation
    /**
     *
     * Like add, but the given numbers are subtracted.
     * @name sub
     * @memberof Pattern
     * @example
     * n("0 2 4".sub("<0 1 2 3>")).scale("C4:minor")
     * // See add for more information.
     */
    sub: [J((n, r) => n - r)],
    /**
     *
     * Multiplies each number by the given factor.
     * @name mul
     * @memberof Pattern
     * @example
     * "<1 1.5 [1.66, <2 2.33>]>*4".mul(150).freq()
     */
    mul: [J((n, r) => n * r)],
    /**
     *
     * Divides each number by the given factor.
     * @name div
     * @memberof Pattern
     */
    div: [J((n, r) => n / r)],
    mod: [J(gt)],
    pow: [J(Math.pow)],
    band: [J((n, r) => n & r)],
    bor: [J((n, r) => n | r)],
    bxor: [J((n, r) => n ^ r)],
    blshift: [J((n, r) => n << r)],
    brshift: [J((n, r) => n >> r)],
    // TODO - force numerical comparison if both look like numbers?
    lt: [(n, r) => n < r],
    gt: [(n, r) => n > r],
    lte: [(n, r) => n <= r],
    gte: [(n, r) => n >= r],
    eq: [(n, r) => n == r],
    eqt: [(n, r) => n === r],
    ne: [(n, r) => n != r],
    net: [(n, r) => n !== r],
    and: [(n, r) => n && r],
    or: [(n, r) => n || r],
    //  bitwise ops
    func: [(n, r) => r(n)]
  }, t = ["In", "Out", "Mix", "Squeeze", "SqueezeOut", "Trig", "Trigzero"];
  for (const [n, [r, o]] of Object.entries(e)) {
    p.prototype["_" + n] = function(s) {
      return this.fmap((i) => r(i, s));
    }, Object.defineProperty(p.prototype, n, {
      // a getter that returns a function, so 'pat' can be
      // accessed by closures that are methods of that function..
      get: function() {
        const s = this, i = (...a) => s[n].in(...a);
        for (const a of t)
          i[a.toLowerCase()] = function(...u) {
            var l = s;
            u = R(u), o && (l = o(l), u = o(u));
            var f;
            return n === "keepif" ? (f = l["_op" + a](u, (h) => (y) => r(h, y)), f = f.removeUndefineds()) : f = l["_op" + a](u, (h) => (y) => Qe(h, y, r)), f;
          };
        return i.squeezein = i.squeeze, i;
      }
    });
    for (const s of t)
      p.prototype[s.toLowerCase()] = function(...i) {
        return this.set[s.toLowerCase()](i);
      };
  }
  p.prototype.struct = function(...n) {
    return this.keepif.out(...n);
  }, p.prototype.structAll = function(...n) {
    return this.keep.out(...n);
  }, p.prototype.mask = function(...n) {
    return this.keepif.in(...n);
  }, p.prototype.maskAll = function(...n) {
    return this.keep.in(...n);
  }, p.prototype.reset = function(...n) {
    return this.keepif.trig(...n);
  }, p.prototype.resetAll = function(...n) {
    return this.keep.trig(...n);
  }, p.prototype.restart = function(...n) {
    return this.keepif.trigzero(...n);
  }, p.prototype.restartAll = function(...n) {
    return this.keep.trigzero(...n);
  };
})();
const Ue = M, Ke = M, Xe = ne;
p.prototype.factories = {
  pure: V,
  stack: M,
  slowcat: U,
  fastcat: K,
  cat: ee,
  timeCat: Ct,
  sequence: R,
  seq: Ye,
  polymeter: ne,
  pm: Xe,
  polyrhythm: Ue,
  pr: Ke
};
const O = new p(() => []);
function V(e) {
  function t(n) {
    return n.span.spanCycles.map((r) => new T(b(r.begin).wholeCycle(), r, e));
  }
  return new p(t);
}
function Zt(e) {
  return e instanceof p || e?._Pattern;
}
function d(e) {
  return Zt(e) ? e : vt && typeof e == "string" ? vt(e) : V(e);
}
function M(...e) {
  e = e.map((n) => Array.isArray(n) ? R(...n) : d(n));
  const t = (n) => Y(e.map((r) => r.query(n)));
  return new p(t);
}
function U(...e) {
  e = e.map((n) => Array.isArray(n) ? R(...n) : d(n));
  const t = function(n) {
    const r = n.span, o = gt(r.begin.sam(), e.length), s = e[o];
    if (!s)
      return [];
    const i = r.begin.floor().sub(r.begin.div(e.length).floor());
    return s.withHapTime((a) => a.add(i)).query(n.setSpan(r.withTime((a) => a.sub(i))));
  };
  return new p(t).splitQueries();
}
function te(...e) {
  e = e.map(d);
  const t = function(n) {
    const r = Math.floor(n.span.begin) % e.length;
    return e[r]?.query(n) || [];
  };
  return new p(t).splitQueries();
}
function ee(...e) {
  return U(...e);
}
function Ct(...e) {
  const t = e.map((o) => o[0]).reduce((o, s) => o.add(s), b(0));
  let n = b(0);
  const r = [];
  for (const [o, s] of e) {
    const i = n.add(o);
    r.push(d(s)._compress(n.div(t), i.div(t))), n = i;
  }
  return M(...r);
}
function tr(...e) {
  const t = e.reduce((n, [r]) => n + r, 0);
  return e = e.map(([n, r]) => [n, r.fast(n)]), Ct(...e).slow(t);
}
function K(...e) {
  return U(...e)._fast(e.length);
}
function R(...e) {
  return K(...e);
}
function Ye(...e) {
  return K(...e);
}
function _t(e) {
  return Array.isArray(e) ? e.length == 0 ? [O, 0] : e.length == 1 ? _t(e[0]) : [K(...e.map((t) => _t(t)[0])), e.length] : [d(e), 1];
}
function Ze(e, ...t) {
  const n = t.map((o) => _t(o));
  if (n.length == 0)
    return O;
  e == 0 && (e = n[0][1]);
  const r = [];
  for (const o of n)
    o[1] != 0 && (e == o[1] ? r.push(o[0]) : r.push(o[0]._fast(b(e).div(b(o[1])))));
  return M(...r);
}
function ne(...e) {
  return Ze(0, ...e);
}
const er = _((e, t) => d(t).mask(e)), nr = _((e, t) => d(t).struct(e)), rr = _((e, t) => d(t).superimpose(...e)), or = _((e, t) => d(t).set(e)), sr = _((e, t) => d(t).keep(e)), ir = _((e, t) => d(t).keepif(e)), cr = _((e, t) => d(t).add(e)), ar = _((e, t) => d(t).sub(e)), ur = _((e, t) => d(t).mul(e)), lr = _((e, t) => d(t).div(e)), fr = _((e, t) => d(t).mod(e)), hr = _((e, t) => d(t).pow(e)), pr = _((e, t) => d(t).band(e)), dr = _((e, t) => d(t).bor(e)), mr = _((e, t) => d(t).bxor(e)), yr = _((e, t) => d(t).blshift(e)), wr = _((e, t) => d(t).brshift(e)), gr = _((e, t) => d(t).lt(e)), br = _((e, t) => d(t).gt(e)), vr = _((e, t) => d(t).lte(e)), _r = _((e, t) => d(t).gte(e)), qr = _((e, t) => d(t).eq(e)), Ar = _((e, t) => d(t).eqt(e)), kr = _((e, t) => d(t).ne(e)), Cr = _((e, t) => d(t).net(e)), Sr = _((e, t) => d(t).and(e)), xr = _((e, t) => d(t).or(e)), Br = _((e, t) => d(t).func(e));
function c(e, t, n = !0) {
  if (Array.isArray(e)) {
    const s = {};
    for (const i of e)
      s[i] = c(i, t, n);
    return s;
  }
  const r = t.length;
  var o;
  return n ? o = function(...s) {
    s = s.map(d);
    const i = s[s.length - 1];
    if (r === 1)
      return t(i);
    const [a, ...u] = s.slice(0, -1);
    let l = (...f) => (Array(r - 1).fill().map((h, y) => f[y] ?? void 0), t(...f, i));
    return l = _(l, null, r - 1), u.reduce((f, h) => f.appLeft(h), a.fmap(l)).innerJoin();
  } : o = function(...s) {
    return s = s.map(d), t(...s);
  }, p.prototype[e] = function(...s) {
    if (r === 2 && s.length !== 1)
      s = [R(...s)];
    else if (r !== s.length + 1)
      throw new Error(`.${e}() expects ${r - 1} inputs but got ${s.length}.`);
    return s = s.map(d), o(...s, this);
  }, r > 1 && (p.prototype["_" + e] = function(...s) {
    return t(...s, this);
  }), _(o, null, r);
}
const Tr = c("round", function(e) {
  return e.asNumber().fmap((t) => Math.round(t));
}), Or = c("floor", function(e) {
  return e.asNumber().fmap((t) => Math.floor(t));
}), Er = c("ceil", function(e) {
  return e.asNumber().fmap((t) => Math.ceil(t));
}), zr = c("toBipolar", function(e) {
  return e.fmap((t) => t * 2 - 1);
}), Pr = c("fromBipolar", function(e) {
  return e.fmap((t) => (t + 1) / 2);
}), Mr = c("range", function(e, t, n) {
  return n.mul(t - e).add(e);
}), jr = c("rangex", function(e, t, n) {
  return n._range(Math.log(e), Math.log(t)).fmap(Math.exp);
}), Fr = c("range2", function(e, t, n) {
  return n.fromBipolar()._range(e, t);
}), Nr = c(
  "ratio",
  (e) => e.fmap((t) => Array.isArray(t) ? t.slice(1).reduce((n, r) => n / r, t[0]) : t)
), $r = c("compress", function(e, t, n) {
  return e = b(e), t = b(t), e.gt(t) || e.gt(1) || t.gt(1) || e.lt(0) || t.lt(0) ? O : n._fastGap(b(1).div(t.sub(e)))._late(e);
}), { compressSpan: Hr, compressspan: Lr } = c(["compressSpan", "compressspan"], function(e, t) {
  return t._compress(e.begin, e.end);
}), { fastGap: Jr, fastgap: Wr } = c(["fastGap", "fastgap"], function(e, t) {
  const n = function(o) {
    const s = o.begin.sam(), i = o.begin.sub(s).mul(e).min(1), a = o.end.sub(s).mul(e).min(1);
    if (!(i >= 1))
      return new x(s.add(i), s.add(a));
  }, r = function(o) {
    const s = o.part.begin, i = o.part.end, a = s.sam(), u = s.sub(a).div(e).min(1), l = i.sub(a).div(e).min(1), f = new x(a.add(u), a.add(l)), h = o.whole ? new x(
      f.begin.sub(s.sub(o.whole.begin).div(e)),
      f.end.add(o.whole.end.sub(i).div(e))
    ) : void 0;
    return new T(h, f, o.value, o.context);
  };
  return t.withQuerySpanMaybe(n).withHap(r).splitQueries();
}), Ir = c("focus", function(e, t, n) {
  return e = b(e), t = b(t), n._fast(b(1).div(t.sub(e))).late(e.cyclePos());
}), { focusSpan: Rr, focusspan: Vr } = c(["focusSpan", "focusspan"], function(e, t) {
  return t._focus(e.begin, e.end);
}), Dr = c("ply", function(e, t) {
  return t.fmap((n) => V(n)._fast(e)).squeezeJoin();
}), { fast: Gr, density: Qr } = c(["fast", "density"], function(e, t) {
  return e === 0 ? O : (e = b(e), t.withQueryTime((r) => r.mul(e)).withHapTime((r) => r.div(e)));
}), Ur = c("hurry", function(e, t) {
  return t._fast(e).mul(V({ speed: e }));
}), { slow: Kr, sparsity: Xr } = c(["slow", "sparsity"], function(e, t) {
  return e === 0 ? O : t._fast(b(1).div(e));
}), Yr = c("inside", function(e, t, n) {
  return t(n._slow(e))._fast(e);
}), Zr = c("outside", function(e, t, n) {
  return t(n._fast(e))._slow(e);
}), to = c("lastOf", function(e, t, n) {
  const r = Array(e - 1).fill(n);
  return r.push(t(n)), te(...r);
}), { firstOf: eo, every: no } = c(["firstOf", "every"], function(e, t, n) {
  const r = Array(e - 1).fill(n);
  return r.unshift(t(n)), te(...r);
}), ro = c("apply", function(e, t) {
  return e(t);
}), oo = c("cpm", function(e, t) {
  return t._fast(e / 60 / 1);
}), so = c("early", function(e, t) {
  return e = b(e), t.withQueryTime((n) => n.add(e)).withHapTime((n) => n.sub(e));
}), io = c("late", function(e, t) {
  return e = b(e), t._early(b(0).sub(e));
}), co = c("zoom", function(e, t, n) {
  t = b(t), e = b(e);
  const r = t.sub(e);
  return n.withQuerySpan((o) => o.withCycle((s) => s.mul(r).add(e))).withHapSpan((o) => o.withCycle((s) => s.sub(e).div(r))).splitQueries();
}), { zoomArc: ao, zoomarc: uo } = c(["zoomArc", "zoomarc"], function(e, t) {
  return t.zoom(e.begin, e.end);
}), lo = c("linger", function(e, t) {
  return e == 0 ? O : e < 0 ? t._zoom(e.add(1), 1)._slow(e) : t._zoom(0, e)._slow(e);
}), fo = c("segment", function(e, t) {
  return t.struct(V(!0)._fast(e));
}), { invert: ho, inv: po } = c(["invert", "inv"], function(e) {
  return e.fmap((t) => !t);
}), mo = c("when", function(e, t, n) {
  return e ? t(n) : n;
}), yo = c("off", function(e, t, n) {
  return M(n, t(n.late(e)));
}), wo = c("brak", function(e) {
  return e.when(U(!1, !0), (t) => K(t, O)._late(0.25));
}), tn = c("rev", function(e) {
  const t = function(n) {
    const r = n.span, o = r.begin.sam(), s = r.begin.nextSam(), i = function(u) {
      const l = u.withTime((h) => o.add(s.sub(h))), f = l.begin;
      return l.begin = l.end, l.end = f, l;
    };
    return e.query(n.setSpan(i(r))).map((u) => u.withSpan(i));
  };
  return new p(t).splitQueries();
}), go = c("pressBy", function(e, t) {
  return t.fmap((n) => V(n).compress(e, 1)).squeezeJoin();
}), bo = c("press", function(e) {
  return e._pressBy(0.5);
});
p.prototype.hush = function() {
  return O;
};
const vo = c("palindrome", function(e) {
  return e.lastOf(2, tn);
}), { juxBy: _o, juxby: qo } = c(["juxBy", "juxby"], function(e, t, n) {
  e /= 2;
  const r = function(i, a, u) {
    return a in i ? i[a] : u;
  }, o = n.withValue((i) => Object.assign({}, i, { pan: r(i, "pan", 0.5) - e })), s = n.withValue((i) => Object.assign({}, i, { pan: r(i, "pan", 0.5) + e }));
  return M(o, t(s));
}), Ao = c("jux", function(e, t) {
  return t._juxBy(1, e, t);
}), { echoWith: ko, echowith: Co, stutWith: So, stutwith: xo } = c(
  ["echoWith", "echowith", "stutWith", "stutwith"],
  function(e, t, n, r) {
    return M(...Qt(0, e - 1).map((o) => n(r.late(b(t).mul(o)), o)));
  }
), Bo = c("echo", function(e, t, n, r) {
  return r._echoWith(e, t, (o, s) => o.velocity(Math.pow(n, s)));
}), To = c("stut", function(e, t, n, r) {
  return r._echoWith(e, n, (o, s) => o.velocity(Math.pow(t, s)));
}), St = function(e, t, n = !1) {
  return e = b(e), U(
    ...Qt(0, e.sub(1)).map(
      (r) => n ? t.late(b(r).div(e)) : t.early(b(r).div(e))
    )
  );
}, Oo = c("iter", function(e, t) {
  return St(e, t, !1);
}), { iterBack: Eo, iterback: zo } = c(["iterBack", "iterback"], function(e, t) {
  return St(e, t, !0);
}), en = function(e, t) {
  return U(...Array(e).fill(t));
};
c("repeatCycles", en);
const xt = function(e, t, n, r = !1, o = !1) {
  const s = Array(e - 1).fill(!1);
  s.unshift(!0);
  const i = St(e, R(...s), !r);
  return o || (n = n.repeatCycles(e)), n.when(i, t);
};
c(["chunk", "slowchunk", "slowChunk"], function(e, t, n) {
  return xt(e, t, n, !1, !1);
});
const { chunkBack: Po, chunkback: Mo } = c(["chunkBack", "chunkback"], function(e, t, n) {
  return xt(e, t, n, !0);
}), { fastchunk: jo, fastChunk: Fo } = c(["fastchunk", "fastChunk"], function(e, t, n) {
  return xt(e, t, n, !1, !0);
}), No = c("bypass", function(e, t) {
  return e = !!parseInt(e), e ? O : t;
}), $o = c("ribbon", (e, t, n) => n.early(e).restart(V(1).slow(t))), Ho = c("duration", function(e, t) {
  return t.withHapSpan((n) => new x(n.begin, n.begin.add(e)));
}), Lo = c("hsla", (e, t, n, r, o) => o.color(`hsla(${e}turn,${t * 100}%,${n * 100}%,${r})`)), Jo = c("hsl", (e, t, n, r) => r.color(`hsl(${e}turn,${t * 100}%,${n * 100}%)`)), { color: Wo, colour: Io } = c(["color", "colour"], function(e, t) {
  return t.withContext((n) => ({ ...n, color: e }));
}), Ro = c("velocity", function(e, t) {
  return t.withContext((n) => ({ ...n, velocity: (n.velocity || 1) * e }));
}), Vo = c("legato", function(e, t) {
  return e = b(e), t.withHapSpan((n) => new x(n.begin, n.begin.add(n.end.sub(n.begin).mul(e))));
}), Do = c("chop", function(e, t) {
  const r = Array.from({ length: e }, (s, i) => i).map((s) => ({ begin: s / e, end: (s + 1) / e })), o = function(s) {
    return R(r.map((i) => Object.assign({}, s, i)));
  };
  return t.squeezeBind(o);
}), Go = c("striate", function(e, t) {
  const r = Array.from({ length: e }, (s, i) => i).map((s) => ({ begin: s / e, end: (s + 1) / e })), o = U(...r);
  return t.set(o)._fast(e);
}), re = function(e, t, n = 0.5) {
  return t.speed(1 / e * n).unit("c").slow(e);
}, nn = c(
  "slice",
  function(e, t, n) {
    return e.innerBind(
      (r) => t.outerBind(
        (o) => n.outerBind((s) => {
          s = s instanceof Object ? s : { s };
          const i = Array.isArray(r) ? r[o] : o / r, a = Array.isArray(r) ? r[o + 1] : (o + 1) / r;
          return V({ begin: i, end: a, _slices: r, ...s });
        })
      )
    );
  },
  !1
  // turns off auto-patternification
), Qo = c(
  "splice",
  function(e, t, n) {
    const r = nn(e, t, n);
    return new p((o) => {
      const s = o.controls._cps || 1;
      return r.query(o).map(
        (a) => a.withValue((u) => ({
          speed: s / u._slices / a.whole.duration * (u.speed || 1),
          unit: "c",
          ...u
        }))
      );
    });
  },
  !1
  // turns off auto-patternification
), { loopAt: Uo, loopat: Ko } = c(["loopAt", "loopat"], function(e, t) {
  return new p((n) => re(e, t, n.controls._cps).query(n));
}), Xo = c(
  "fit",
  (e) => e.withHaps(
    (t, n) => t.map(
      (r) => r.withValue((o) => ({
        ...o,
        speed: (n.controls._cps || 1) / r.whole.duration,
        unit: "c"
      }))
    )
  )
), { loopAtCps: Yo, loopatcps: Zo } = c(["loopAtCps", "loopatcps"], function(e, t, n) {
  return re(e, n, t);
}), ts = (e) => V(1).withValue(() => d(e())).innerJoin();
let Lt = (e) => e < 0.5 ? 1 : 1 - (e - 0.5) / 0.5, rn = (e, t, n) => {
  t = d(t), e = d(e), n = d(n);
  let r = t.fmap((s) => ({ gain: Lt(s) })), o = t.fmap((s) => ({ gain: Lt(1 - s) }));
  return M(e.mul(r), n.mul(o));
};
p.prototype.xfade = function(e, t) {
  return rn(this, e, t);
};
const L = {}, on = [
  /**
   * Select a sound / sample by name. When using mininotation, you can also optionally supply 'n' and 'gain' parameters
   * separated by ':'.
   *
   * @name s
   * @param {string | Pattern} sound The sound / pattern of sounds to pick
   * @synonyms sound
   * @example
   * s("bd hh")
   * @example
   * s("bd:0 bd:1 bd:0:0.3 bd:1:1.4")
   *
   */
  [["s", "n", "gain"], "sound"],
  /**
   * Define a custom webaudio node to use as a sound source.
   *
   * @name source
   * @param {function} getSource
   * @synonyms src
   *
   */
  ["source", "src"],
  /**
   * Selects the given index from the sample map.
   * Numbers too high will wrap around.
   * `n` can also be used to play midi numbers, but it is recommended to use `note` instead.
   *
   * @name n
   * @param {number | Pattern} value sample index starting from 0
   * @example
   * s("bd sd [~ bd] sd,hh*6").n("<0 1>")
   */
  // also see https://github.com/tidalcycles/strudel/pull/63
  ["n"],
  /**
   * Plays the given note name or midi number. A note name consists of
   *
   * - a letter (a-g or A-G)
   * - optional accidentals (b or #)
   * - optional octave number (0-9). Defaults to 3
   *
   * Examples of valid note names: `c`, `bb`, `Bb`, `f#`, `c3`, `A4`, `Eb2`, `c#5`
   *
   * You can also use midi numbers instead of note names, where 69 is mapped to A4 440Hz in 12EDO.
   *
   * @name note
   * @example
   * note("c a f e")
   * @example
   * note("c4 a4 f4 e4")
   * @example
   * note("60 69 65 64")
   */
  [["note", "n"]],
  /**
   * A pattern of numbers that speed up (or slow down) samples while they play. Currently only supported by osc / superdirt.
   *
   * @name accelerate
   * @param {number | Pattern} amount acceleration.
   * @superdirtOnly
   * @example
   * s("sax").accelerate("<0 1 2 4 8 16>").slow(2).osc()
   *
   */
  ["accelerate"],
  /**
   * Controls the gain by an exponential amount.
   *
   * @name gain
   * @param {number | Pattern} amount gain.
   * @example
   * s("hh*8").gain(".4!2 1 .4!2 1 .4 1").fast(2)
   *
   */
  ["gain"],
  /**
   * Gain applied after all effects have been processed.
   *
   * @name postgain
   * @example
   * s("bd sd [~ bd] sd,hh*8")
   * .compressor("-20:20:10:.002:.02").postgain(1.5)
   *
   */
  ["postgain"],
  /**
   * Like `gain`, but linear.
   *
   * @name amp
   * @param {number | Pattern} amount gain.
   * @superdirtOnly
   * @example
   * s("bd*8").amp(".1*2 .5 .1*2 .5 .1 .5").osc()
   *
   */
  ["amp"],
  /**
   * Amplitude envelope attack time: Specifies how long it takes for the sound to reach its peak value, relative to the onset.
   *
   * @name attack
   * @param {number | Pattern} attack time in seconds.
   * @synonyms att
   * @example
   * note("c3 e3 f3 g3").attack("<0 .1 .5>")
   *
   */
  ["attack", "att"],
  /**
   * Sets the Frequency Modulation Harmonicity Ratio.
   * Controls the timbre of the sound.
   * Whole numbers and simple ratios sound more natural,
   * while decimal numbers and complex ratios sound metallic.
   *
   * @name fmh
   * @param {number | Pattern} harmonicity
   * @example
   * note("c e g b g e")
   * .fm(4)
   * .fmh("<1 2 1.5 1.61>")
   * .scope()
   *
   */
  [["fmh", "fmi"], "fmh"],
  /**
   * Sets the Frequency Modulation of the synth.
   * Controls the modulation index, which defines the brightness of the sound.
   *
   * @name fm
   * @param {number | Pattern} brightness modulation index
   * @synonyms fmi
   * @example
   * note("c e g b g e")
   * .fm("<0 1 2 8 32>")
   * .scope()
   *
   */
  [["fmi", "fmh"], "fm"],
  // fm envelope
  /**
   * Ramp type of fm envelope. Exp might be a bit broken..
   *
   * @name fmenv
   * @param {number | Pattern} type lin | exp
   * @example
   * note("c e g b g e")
   * .fm(4)
   * .fmdecay(.2)
   * .fmsustain(0)
   * .fmenv("<exp lin>")
   * .scope()
   *
   */
  ["fmenv"],
  /**
   * Attack time for the FM envelope: time it takes to reach maximum modulation
   *
   * @name fmattack
   * @param {number | Pattern} time attack time
   * @example
   * note("c e g b g e")
   * .fm(4)
   * .fmattack("<0 .05 .1 .2>")
   * .scope()
   *
   */
  ["fmattack"],
  /**
   * Decay time for the FM envelope: seconds until the sustain level is reached after the attack phase.
   *
   * @name fmdecay
   * @param {number | Pattern} time decay time
   * @example
   * note("c e g b g e")
   * .fm(4)
   * .fmdecay("<.01 .05 .1 .2>")
   * .fmsustain(.4)
   * .scope()
   *
   */
  ["fmdecay"],
  /**
   * Sustain level for the FM envelope: how much modulation is applied after the decay phase
   *
   * @name fmsustain
   * @param {number | Pattern} level sustain level
   * @example
   * note("c e g b g e")
   * .fm(4)
   * .fmdecay(.1)
   * .fmsustain("<1 .75 .5 0>")
   * .scope()
   *
   */
  ["fmsustain"],
  // these are not really useful... skipping for now
  ["fmrelease"],
  ["fmvelocity"],
  /**
   * Select the sound bank to use. To be used together with `s`. The bank name (+ "_") will be prepended to the value of `s`.
   *
   * @name bank
   * @param {string | Pattern} bank the name of the bank
   * @example
   * s("bd sd [~ bd] sd").bank('RolandTR909') // = s("RolandTR909_bd RolandTR909_sd")
   *
   */
  ["bank"],
  ["analyze"],
  // analyser node send amount 0 - 1 (used by scope)
  ["fft"],
  // fftSize of analyser
  /**
   * Amplitude envelope decay time: the time it takes after the attack time to reach the sustain level.
   * Note that the decay is only audible if the sustain value is lower than 1.
   *
   * @name decay
   * @param {number | Pattern} time decay time in seconds
   * @example
   * note("c3 e3 f3 g3").decay("<.1 .2 .3 .4>").sustain(0)
   *
   */
  ["decay", "dec"],
  /**
   * Amplitude envelope sustain level: The level which is reached after attack / decay, being sustained until the offset.
   *
   * @name sustain
   * @param {number | Pattern} gain sustain level between 0 and 1
   * @synonyms sus
   * @example
   * note("c3 e3 f3 g3").decay(.2).sustain("<0 .1 .4 .6 1>")
   *
   */
  ["sustain", "sus"],
  /**
   * Amplitude envelope release time: The time it takes after the offset to go from sustain level to zero.
   *
   * @name release
   * @param {number | Pattern} time release time in seconds
   * @synonyms rel
   * @example
   * note("c3 e3 g3 c4").release("<0 .1 .4 .6 1>/2")
   *
   */
  ["release", "rel"],
  ["hold"],
  // TODO: in tidal, it seems to be normalized
  /**
   * Sets the center frequency of the **b**and-**p**ass **f**ilter. When using mininotation, you
   * can also optionally supply the 'bpq' parameter separated by ':'.
   *
   * @name bpf
   * @param {number | Pattern} frequency center frequency
   * @synonyms bandf, bp
   * @example
   * s("bd sd [~ bd] sd,hh*6").bpf("<1000 2000 4000 8000>")
   *
   */
  [["bandf", "bandq", "bpenv"], "bpf", "bp"],
  // TODO: in tidal, it seems to be normalized
  /**
   * Sets the **b**and-**p**ass **q**-factor (resonance).
   *
   * @name bpq
   * @param {number | Pattern} q q factor
   * @synonyms bandq
   * @example
   * s("bd sd [~ bd] sd").bpf(500).bpq("<0 1 2 3>")
   *
   */
  // currently an alias of 'bandq' https://github.com/tidalcycles/strudel/issues/496
  // ['bpq'],
  ["bandq", "bpq"],
  /**
   * a pattern of numbers from 0 to 1. Skips the beginning of each sample, e.g. `0.25` to cut off the first quarter from each sample.
   *
   * @memberof Pattern
   * @name begin
   * @param {number | Pattern} amount between 0 and 1, where 1 is the length of the sample
   * @example
   * samples({ rave: 'rave/AREUREADY.wav' }, 'github:tidalcycles/Dirt-Samples/master/')
   * s("rave").begin("<0 .25 .5 .75>").fast(2)
   *
   */
  ["begin"],
  /**
   * The same as .begin, but cuts off the end off each sample.
   *
   * @memberof Pattern
   * @name end
   * @param {number | Pattern} length 1 = whole sample, .5 = half sample, .25 = quarter sample etc..
   * @example
   * s("bd*2,oh*4").end("<.1 .2 .5 1>").fast(2)
   *
   */
  ["end"],
  /**
   * Loops the sample.
   * Note that the tempo of the loop is not synced with the cycle tempo.
   * To change the loop region, use loopBegin / loopEnd.
   *
   * @name loop
   * @param {number | Pattern} on If 1, the sample is looped
   * @example
   * s("casio").loop(1)
   *
   */
  ["loop"],
  /**
   * Begin to loop at a specific point in the sample (inbetween `begin` and `end`).
   * Note that the loop point must be inbetween `begin` and `end`, and before `loopEnd`!
   * Note: Samples starting with wt_ will automatically loop! (wt = wavetable)
   *
   * @name loopBegin
   * @param {number | Pattern} time between 0 and 1, where 1 is the length of the sample
   * @synonyms loopb
   * @example
   * s("space").loop(1)
   * .loopBegin("<0 .125 .25>").scope()
   */
  ["loopBegin", "loopb"],
  /**
   *
   * End the looping section at a specific point in the sample (inbetween `begin` and `end`).
   * Note that the loop point must be inbetween `begin` and `end`, and after `loopBegin`!
   *
   * @name loopEnd
   * @param {number | Pattern} time between 0 and 1, where 1 is the length of the sample
   * @synonyms loope
   * @example
   * s("space").loop(1)
   * .loopEnd("<1 .75 .5 .25>").scope()
   */
  ["loopEnd", "loope"],
  /**
   * bit crusher effect.
   *
   * @name crush
   * @param {number | Pattern} depth between 1 (for drastic reduction in bit-depth) to 16 (for barely no reduction).
   * @example
   * s("<bd sd>,hh*3").fast(2).crush("<16 8 7 6 5 4 3 2>")
   *
   */
  // TODO: currently duplicated with "native" legato
  // TODO: superdirt legato will do more: https://youtu.be/dQPmE1WaD1k?t=419
  /**
   * a pattern of numbers from 0 to 1. Skips the beginning of each sample, e.g. `0.25` to cut off the first quarter from each sample.
   *
   * @name legato
   * @param {number | Pattern} duration between 0 and 1, where 1 is the length of the whole hap time
   * @noAutocomplete
   * @example
   * "c4 eb4 g4 bb4".legato("<0.125 .25 .5 .75 1 2 4>")
   *
   */
  // ['legato'],
  // ['clhatdecay'],
  ["crush"],
  /**
   * fake-resampling for lowering the sample rate. Caution: This effect seems to only work in chromium based browsers
   *
   * @name coarse
   * @param {number | Pattern} factor 1 for original 2 for half, 3 for a third and so on.
   * @example
   * s("bd sd [~ bd] sd,hh*8").coarse("<1 4 8 16 32>")
   *
   */
  ["coarse"],
  /**
   * Allows you to set the output channels on the interface
   *
   * @name channels
   * @synonyms ch
   *
   * @param {number | Pattern} channels pattern the output channels
   * @example
   * note("e a d b g").channels("3:4")
   *
   */
  ["channels", "ch"],
  ["phaserrate", "phasr"],
  // superdirt only
  /**
   * Phaser audio effect that approximates popular guitar pedals.
   *
   * @name phaser
   * @synonyms ph
   * @param {number | Pattern} speed speed of modulation
   * @example
   * n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)
   * .phaser("<1 2 4 8>")
   *
   */
  [["phaser", "phaserdepth", "phasercenter", "phasersweep"], "ph"],
  /**
   * The frequency sweep range of the lfo for the phaser effect. Defaults to 2000
   *
   * @name phasersweep
   * @synonyms phs
   * @param {number | Pattern} phasersweep most useful values are between 0 and 4000
   * @example
   * n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)
   * .phaser(2).phasersweep("<800 2000 4000>")
   *
   */
  ["phasersweep", "phs"],
  /**
   *  The center frequency of the phaser in HZ. Defaults to 1000
   *
   * @name phasercenter
   * @synonyms phc
   * @param {number | Pattern} centerfrequency in HZ
   * @example
   * n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)
   * .phaser(2).phasercenter("<800 2000 4000>")
   *
   */
  ["phasercenter", "phc"],
  /**
   * The amount the signal is affected by the phaser effect. Defaults to 0.75
   *
   * @name phaserdepth
   * @synonyms phd
   * @param {number | Pattern} depth number between 0 and 1
   * @example
   * n(run(8)).scale("D:pentatonic").s("sawtooth").release(0.5)
   * .phaser(2).phaserdepth("<0 .5 .75 1>")
   *
   */
  ["phaserdepth", "phd", "phasdp"],
  // also a superdirt control
  /**
   * choose the channel the pattern is sent to in superdirt
   *
   * @name channel
   * @param {number | Pattern} channel channel number
   *
   */
  ["channel"],
  /**
   * In the style of classic drum-machines, `cut` will stop a playing sample as soon as another samples with in same cutgroup is to be played. An example would be an open hi-hat followed by a closed one, essentially muting the open.
   *
   * @name cut
   * @param {number | Pattern} group cut group number
   * @example
   * s("[oh hh]*4").cut(1)
   *
   */
  ["cut"],
  /**
   * Applies the cutoff frequency of the **l**ow-**p**ass **f**ilter.
   *
   * When using mininotation, you can also optionally add the 'lpq' parameter, separated by ':'.
   *
   * @name lpf
   * @param {number | Pattern} frequency audible between 0 and 20000
   * @synonyms cutoff, ctf, lp
   * @example
   * s("bd sd [~ bd] sd,hh*6").lpf("<4000 2000 1000 500 200 100>")
   * @example
   * s("bd*16").lpf("1000:0 1000:10 1000:20 1000:30")
   *
   */
  [["cutoff", "resonance", "lpenv"], "ctf", "lpf", "lp"],
  /**
   * Sets the lowpass filter envelope modulation depth.
   * @name lpenv
   * @param {number | Pattern} modulation depth of the lowpass filter envelope between 0 and _n_
   * @synonyms lpe
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .lpf(500)
   * .lpa(.5)
   * .lpenv("<4 2 1 0 -1 -2 -4>/4")
   */
  ["lpenv", "lpe"],
  /**
   * Sets the highpass filter envelope modulation depth.
   * @name hpenv
   * @param {number | Pattern} modulation depth of the highpass filter envelope between 0 and _n_
   * @synonyms hpe
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .hpf(500)
   * .hpa(.5)
   * .hpenv("<4 2 1 0 -1 -2 -4>/4")
   */
  ["hpenv", "hpe"],
  /**
   * Sets the bandpass filter envelope modulation depth.
   * @name bpenv
   * @param {number | Pattern} modulation depth of the bandpass filter envelope between 0 and _n_
   * @synonyms bpe
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .bpf(500)
   * .bpa(.5)
   * .bpenv("<4 2 1 0 -1 -2 -4>/4")
   */
  ["bpenv", "bpe"],
  /**
   * Sets the attack duration for the lowpass filter envelope.
   * @name lpattack
   * @param {number | Pattern} attack time of the filter envelope
   * @synonyms lpa
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .lpf(500)
   * .lpa("<.5 .25 .1 .01>/4")
   * .lpenv(4)
   */
  ["lpattack", "lpa"],
  /**
   * Sets the attack duration for the highpass filter envelope.
   * @name hpattack
   * @param {number | Pattern} attack time of the highpass filter envelope
   * @synonyms hpa
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .hpf(500)
   * .hpa("<.5 .25 .1 .01>/4")
   * .hpenv(4)
   */
  ["hpattack", "hpa"],
  /**
   * Sets the attack duration for the bandpass filter envelope.
   * @name bpattack
   * @param {number | Pattern} attack time of the bandpass filter envelope
   * @synonyms bpa
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .bpf(500)
   * .bpa("<.5 .25 .1 .01>/4")
   * .bpenv(4)
   */
  ["bpattack", "bpa"],
  /**
   * Sets the decay duration for the lowpass filter envelope.
   * @name lpdecay
   * @param {number | Pattern} decay time of the filter envelope
   * @synonyms lpd
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .lpf(500)
   * .lpd("<.5 .25 .1 0>/4")
   * .lps(0.2)
   * .lpenv(4)
   */
  ["lpdecay", "lpd"],
  /**
   * Sets the decay duration for the highpass filter envelope.
   * @name hpdecay
   * @param {number | Pattern} decay time of the highpass filter envelope
   * @synonyms hpd
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .hpf(500)
   * .hpd("<.5 .25 .1 0>/4")
   * .hps(0.2)
   * .hpenv(4)
   */
  ["hpdecay", "hpd"],
  /**
   * Sets the decay duration for the bandpass filter envelope.
   * @name bpdecay
   * @param {number | Pattern} decay time of the bandpass filter envelope
   * @synonyms bpd
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .bpf(500)
   * .bpd("<.5 .25 .1 0>/4")
   * .bps(0.2)
   * .bpenv(4)
   */
  ["bpdecay", "bpd"],
  /**
   * Sets the sustain amplitude for the lowpass filter envelope.
   * @name lpsustain
   * @param {number | Pattern} sustain amplitude of the lowpass filter envelope
   * @synonyms lps
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .lpf(500)
   * .lpd(.5)
   * .lps("<0 .25 .5 1>/4")
   * .lpenv(4)
   */
  ["lpsustain", "lps"],
  /**
   * Sets the sustain amplitude for the highpass filter envelope.
   * @name hpsustain
   * @param {number | Pattern} sustain amplitude of the highpass filter envelope
   * @synonyms hps
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .hpf(500)
   * .hpd(.5)
   * .hps("<0 .25 .5 1>/4")
   * .hpenv(4)
   */
  ["hpsustain", "hps"],
  /**
   * Sets the sustain amplitude for the bandpass filter envelope.
   * @name bpsustain
   * @param {number | Pattern} sustain amplitude of the bandpass filter envelope
   * @synonyms bps
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .bpf(500)
   * .bpd(.5)
   * .bps("<0 .25 .5 1>/4")
   * .bpenv(4)
   */
  ["bpsustain", "bps"],
  /**
   * Sets the release time for the lowpass filter envelope.
   * @name lprelease
   * @param {number | Pattern} release time of the filter envelope
   * @synonyms lpr
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .clip(.5)
   * .lpf(500)
   * .lpenv(4)
   * .lpr("<.5 .25 .1 0>/4")
   * .release(.5)
   */
  ["lprelease", "lpr"],
  /**
   * Sets the release time for the highpass filter envelope.
   * @name hprelease
   * @param {number | Pattern} release time of the highpass filter envelope
   * @synonyms hpr
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .clip(.5)
   * .hpf(500)
   * .hpenv(4)
   * .hpr("<.5 .25 .1 0>/4")
   * .release(.5)
   */
  ["hprelease", "hpr"],
  /**
   * Sets the release time for the bandpass filter envelope.
   * @name bprelease
   * @param {number | Pattern} release time of the bandpass filter envelope
   * @synonyms bpr
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .clip(.5)
   * .bpf(500)
   * .bpenv(4)
   * .bpr("<.5 .25 .1 0>/4")
   * .release(.5)
   */
  ["bprelease", "bpr"],
  /**
   * Sets the filter type. The 24db filter is more aggressive. More types might be added in the future.
   * @name ftype
   * @param {number | Pattern} type 12db (default) or 24db
   * @example
   * note("c2 e2 f2 g2")
   * .sound('sawtooth')
   * .lpf(500)
   * .bpenv(4)
   * .ftype("12db 24db")
   */
  ["ftype"],
  ["fanchor"],
  /**
   * Applies the cutoff frequency of the **h**igh-**p**ass **f**ilter.
   *
   * When using mininotation, you can also optionally add the 'hpq' parameter, separated by ':'.
   *
   * @name hpf
   * @param {number | Pattern} frequency audible between 0 and 20000
   * @synonyms hp, hcutoff
   * @example
   * s("bd sd [~ bd] sd,hh*8").hpf("<4000 2000 1000 500 200 100>")
   * @example
   * s("bd sd [~ bd] sd,hh*8").hpf("<2000 2000:25>")
   *
   */
  // currently an alias of 'hcutoff' https://github.com/tidalcycles/strudel/issues/496
  // ['hpf'],
  /**
   * Applies a vibrato to the frequency of the oscillator.
   *
   * @name vib
   * @synonyms vibrato, v
   * @param {number | Pattern} frequency of the vibrato in hertz
   * @example
   * note("a e")
   * .vib("<.5 1 2 4 8 16>")
   * @example
   * // change the modulation depth with ":"
   * note("a e")
   * .vib("<.5 1 2 4 8 16>:12")
   */
  [["vib", "vibmod"], "vibrato", "v"],
  /**
   * Adds pink noise to the mix
   *
   * @name noise
   * @param {number | Pattern} wet wet amount
   * @example
   * sound("<white pink brown>/2")
   */
  ["noise"],
  /**
   * Sets the vibrato depth in semitones. Only has an effect if `vibrato` | `vib` | `v` is is also set
   *
   * @name vibmod
   * @synonyms vmod
   * @param {number | Pattern} depth of vibrato (in semitones)
   * @example
   * note("a e").vib(4)
   * .vibmod("<.25 .5 1 2 12>")
   * @example
   * // change the vibrato frequency with ":"
   * note("a e")
   * .vibmod("<.25 .5 1 2 12>:8")
   */
  [["vibmod", "vib"], "vmod"],
  [["hcutoff", "hresonance", "hpenv"], "hpf", "hp"],
  /**
   * Controls the **h**igh-**p**ass **q**-value.
   *
   * @name hpq
   * @param {number | Pattern} q resonance factor between 0 and 50
   * @synonyms hresonance
   * @example
   * s("bd sd [~ bd] sd,hh*8").hpf(2000).hpq("<0 10 20 30>")
   *
   */
  ["hresonance", "hpq"],
  /**
   * Controls the **l**ow-**p**ass **q**-value.
   *
   * @name lpq
   * @param {number | Pattern} q resonance factor between 0 and 50
   * @synonyms resonance
   * @example
   * s("bd sd [~ bd] sd,hh*8").lpf(2000).lpq("<0 10 20 30>")
   *
   */
  // currently an alias of 'resonance' https://github.com/tidalcycles/strudel/issues/496
  ["resonance", "lpq"],
  /**
   * DJ filter, below 0.5 is low pass filter, above is high pass filter.
   *
   * @name djf
   * @param {number | Pattern} cutoff below 0.5 is low pass filter, above is high pass filter
   * @example
   * n("0 3 7 [10,24]").s('superzow').octave(3).djf("<.5 .25 .5 .75>").osc()
   *
   */
  ["djf"],
  // ['cutoffegint'],
  // TODO: does not seem to work
  /**
   * Sets the level of the delay signal.
   *
   * When using mininotation, you can also optionally add the 'delaytime' and 'delayfeedback' parameter,
   * separated by ':'.
   *
   *
   * @name delay
   * @param {number | Pattern} level between 0 and 1
   * @example
   * s("bd bd").delay("<0 .25 .5 1>")
   * @example
   * s("bd bd").delay("0.65:0.25:0.9 0.65:0.125:0.7")
   *
   */
  [["delay", "delaytime", "delayfeedback"]],
  /**
   * Sets the level of the signal that is fed back into the delay.
   * Caution: Values >= 1 will result in a signal that gets louder and louder! Don't do it
   *
   * @name delayfeedback
   * @param {number | Pattern} feedback between 0 and 1
   * @synonyms delayfb, dfb
   * @example
   * s("bd").delay(.25).delayfeedback("<.25 .5 .75 1>")
   *
   */
  ["delayfeedback", "delayfb", "dfb"],
  /**
   * Sets the time of the delay effect.
   *
   * @name delaytime
   * @param {number | Pattern} seconds between 0 and Infinity
   * @synonyms delayt, dt
   * @example
   * s("bd bd").delay(.25).delaytime("<.125 .25 .5 1>")
   *
   */
  ["delaytime", "delayt", "dt"],
  /* // TODO: test
   * Specifies whether delaytime is calculated relative to cps.
   *
   * @name lock
   * @param {number | Pattern} enable When set to 1, delaytime is a direct multiple of a cycle.
   * @example
   * s("sd").delay().lock(1).osc()
   *
   */
  ["lock"],
  /**
   * Set detune of oscillators. Works only with some synths, see <a target="_blank" href="https://tidalcycles.org/docs/patternlib/tutorials/synthesizers">tidal doc</a>
   *
   * @name detune
   * @param {number | Pattern} amount between 0 and 1
   * @synonyms det
   * @superdirtOnly
   * @example
   * n("0 3 7").s('superzow').octave(3).detune("<0 .25 .5 1 2>").osc()
   *
   */
  ["detune", "det"],
  /**
   * Set dryness of reverb. See `room` and `size` for more information about reverb.
   *
   * @name dry
   * @param {number | Pattern} dry 0 = wet, 1 = dry
   * @example
   * n("[0,3,7](3,8)").s("superpiano").room(.7).dry("<0 .5 .75 1>").osc()
   * @superdirtOnly
   *
   */
  ["dry"],
  // TODO: does not seem to do anything
  /*
   * Used when using `begin`/`end` or `chop`/`striate` and friends, to change the fade out time of the 'grain' envelope.
   *
   * @name fadeTime
   * @param {number | Pattern} time between 0 and 1
   * @example
   * s("oh*4").end(.1).fadeTime("<0 .2 .4 .8>").osc()
   *
   */
  ["fadeTime", "fadeOutTime"],
  // TODO: see above
  ["fadeInTime"],
  /**
   * Set frequency of sound.
   *
   * @name freq
   * @param {number | Pattern} frequency in Hz. the audible range is between 20 and 20000 Hz
   * @example
   * freq("220 110 440 110").s("superzow").osc()
   * @example
   * freq("110".mul.out(".5 1.5 .6 [2 3]")).s("superzow").osc()
   *
   */
  ["freq"],
  // pitch envelope
  /**
   * Attack time of pitch envelope.
   *
   * @name pattack
   * @synonyms patt
   * @param {number | Pattern} time time in seconds
   * @example
   * note("c eb g bb").pattack("0 .1 .25 .5").slow(2)
   *
   */
  ["pattack", "patt"],
  /**
   * Decay time of pitch envelope.
   *
   * @name pdecay
   * @synonyms pdec
   * @param {number | Pattern} time time in seconds
   * @example
   * note("<c eb g bb>").pdecay("<0 .1 .25 .5>")
   *
   */
  ["pdecay", "pdec"],
  // TODO: how to use psustain?!
  ["psustain", "psus"],
  /**
   * Release time of pitch envelope
   *
   * @name prelease
   * @synonyms prel
   * @param {number | Pattern} time time in seconds
   * @example
   * note("<c eb g bb> ~")
   * .release(.5) // to hear the pitch release
   * .prelease("<0 .1 .25 .5>")
   *
   */
  ["prelease", "prel"],
  /**
   * Amount of pitch envelope. Negative values will flip the envelope.
   * If you don't set other pitch envelope controls, `pattack:.2` will be the default.
   *
   * @name penv
   * @param {number | Pattern} semitones change in semitones
   * @example
   * note("c")
   * .penv("<12 7 1 .5 0 -1 -7 -12>")
   *
   */
  ["penv"],
  /**
   * Curve of envelope. Defaults to linear. exponential is good for kicks
   *
   * @name pcurve
   * @param {number | Pattern} type 0 = linear, 1 = exponential
   * @example
   * note("g1*4")
   * .s("sine").pdec(.5)
   * .penv(32)
   * .pcurve("<0 1>")
   *
   */
  ["pcurve"],
  /**
   * Sets the range anchor of the envelope:
   * - anchor 0: range = [note, note + penv]
   * - anchor 1: range = [note - penv, note]
   * If you don't set an anchor, the value will default to the psustain value.
   *
   * @name panchor
   * @param {number | Pattern} anchor anchor offset
   * @example
   * note("c c4").penv(12).panchor("<0 .5 1 .5>")
   *
   */
  ["panchor"],
  // TODO: https://tidalcycles.org/docs/configuration/MIDIOSC/control-voltage/#gate
  ["gate", "gat"],
  // ['hatgrain'],
  // ['lagogo'],
  // ['lclap'],
  // ['lclaves'],
  // ['lclhat'],
  // ['lcrash'],
  // TODO:
  // https://tidalcycles.org/docs/reference/audio_effects/#leslie-1
  // https://tidalcycles.org/docs/reference/audio_effects/#leslie
  /**
   * Emulation of a Leslie speaker: speakers rotating in a wooden amplified cabinet.
   *
   * @name leslie
   * @param {number | Pattern} wet between 0 and 1
   * @example
   * n("0,4,7").s("supersquare").leslie("<0 .4 .6 1>").osc()
   * @superdirtOnly
   *
   */
  ["leslie"],
  /**
   * Rate of modulation / rotation for leslie effect
   *
   * @name lrate
   * @param {number | Pattern} rate 6.7 for fast, 0.7 for slow
   * @example
   * n("0,4,7").s("supersquare").leslie(1).lrate("<1 2 4 8>").osc()
   * @superdirtOnly
   *
   */
  // TODO: the rate seems to "lag" (in the example, 1 will be fast)
  ["lrate"],
  /**
   * Physical size of the cabinet in meters. Be careful, it might be slightly larger than your computer. Affects the Doppler amount (pitch warble)
   *
   * @name lsize
   * @param {number | Pattern} meters somewhere between 0 and 1
   * @example
   * n("0,4,7").s("supersquare").leslie(1).lrate(2).lsize("<.1 .5 1>").osc()
   * @superdirtOnly
   *
   */
  ["lsize"],
  /**
   * Sets the displayed text for an event on the pianoroll
   *
   * @name label
   * @param {string} label text to display
   */
  ["activeLabel"],
  [["label", "activeLabel"]],
  // ['lfo'],
  // ['lfocutoffint'],
  // ['lfodelay'],
  // ['lfoint'],
  // ['lfopitchint'],
  // ['lfoshape'],
  // ['lfosync'],
  // ['lhitom'],
  // ['lkick'],
  // ['llotom'],
  // ['lophat'],
  // ['lsnare'],
  ["degree"],
  // TODO: what is this? not found in tidal doc
  ["mtranspose"],
  // TODO: what is this? not found in tidal doc
  ["ctranspose"],
  // TODO: what is this? not found in tidal doc
  ["harmonic"],
  // TODO: what is this? not found in tidal doc
  ["stepsPerOctave"],
  // TODO: what is this? not found in tidal doc
  ["octaveR"],
  // TODO: what is this? not found in tidal doc
  // TODO: why is this needed? what's the difference to late / early? Answer: it's in seconds, and delays the message at
  // OSC time (so can't be negative, at least not beyond the latency value)
  ["nudge"],
  // TODO: the following doc is just a guess, it's not documented in tidal doc.
  /**
   * Sets the default octave of a synth.
   *
   * @name octave
   * @param {number | Pattern} octave octave number
   * @example
   * n("0,4,7").s('supersquare').octave("<3 4 5 6>").osc()
   * @superDirtOnly
   */
  ["octave"],
  // ['ophatdecay'],
  // TODO: example
  /**
   * An `orbit` is a global parameter context for patterns. Patterns with the same orbit will share the same global effects.
   *
   * @name orbit
   * @param {number | Pattern} number
   * @example
   * stack(
   *   s("hh*6").delay(.5).delaytime(.25).orbit(1),
   *   s("~ sd ~ sd").delay(.5).delaytime(.125).orbit(2)
   * )
   */
  ["orbit"],
  ["overgain"],
  // TODO: what is this? not found in tidal doc Answer: gain is limited to maximum of 2. This allows you to go over that
  ["overshape"],
  // TODO: what is this? not found in tidal doc. Similar to above, but limited to 1
  /**
   * Sets position in stereo.
   *
   * @name pan
   * @param {number | Pattern} pan between 0 and 1, from left to right (assuming stereo), once round a circle (assuming multichannel)
   * @example
   * s("[bd hh]*2").pan("<.5 1 .5 0>")
   * @example
   * s("bd rim sd rim bd ~ cp rim").pan(sine.slow(2))
   *
   */
  ["pan"],
  // TODO: this has no effect (see example)
  /*
   * Controls how much multichannel output is fanned out
   *
   * @name panspan
   * @param {number | Pattern} span between -inf and inf, negative is backwards ordering
   * @example
   * s("[bd hh]*2").pan("<.5 1 .5 0>").panspan("<0 .5 1>").osc()
   *
   */
  ["panspan"],
  // TODO: this has no effect (see example)
  /*
   * Controls how much multichannel output is spread
   *
   * @name pansplay
   * @param {number | Pattern} spread between 0 and 1
   * @example
   * s("[bd hh]*2").pan("<.5 1 .5 0>").pansplay("<0 .5 1>").osc()
   *
   */
  ["pansplay"],
  ["panwidth"],
  ["panorient"],
  // ['pitch1'],
  // ['pitch2'],
  // ['pitch3'],
  // ['portamento'],
  // TODO: LFO rate see https://tidalcycles.org/docs/patternlib/tutorials/synthesizers/#supersquare
  ["rate"],
  // TODO: slide param for certain synths
  ["slide"],
  // TODO: detune? https://tidalcycles.org/docs/patternlib/tutorials/synthesizers/#supersquare
  ["semitone"],
  // TODO: dedup with synth param, see https://tidalcycles.org/docs/reference/synthesizers/#superpiano
  // ['velocity'],
  ["voice"],
  // TODO: synth param
  // voicings // https://github.com/tidalcycles/strudel/issues/506
  ["chord"],
  // chord to voice, like C Eb Fm7 G7. the symbols can be defined via addVoicings
  ["dictionary", "dict"],
  // which dictionary to use for the voicings
  ["anchor"],
  // the top note to align the voicing to, defaults to c5
  ["offset"],
  // how the voicing is offset from the anchored position
  ["octaves"],
  // how many octaves are voicing steps spread apart, defaults to 1
  [["mode", "anchor"]],
  // below = anchor note will be removed from the voicing, useful for melody harmonization
  /**
   * Sets the level of reverb.
   *
   * When using mininotation, you can also optionally add the 'size' parameter, separated by ':'.
   *
   * @name room
   * @param {number | Pattern} level between 0 and 1
   * @example
   * s("bd sd [~ bd] sd").room("<0 .2 .4 .6 .8 1>")
   * @example
   * s("bd sd [~ bd] sd").room("<0.9:1 0.9:4>")
   *
   */
  [["room", "size"]],
  /**
   * Reverb lowpass starting frequency (in hertz).
   * When this property is changed, the reverb will be recaculated, so only change this sparsely..
   *
   * @name roomlp
   * @synonyms rlp
   * @param {number} frequency between 0 and 20000hz
   * @example
   * s("bd sd [~ bd] sd").room(0.5).rlp(10000)
   * @example
   * s("bd sd [~ bd] sd").room(0.5).rlp(5000)
   */
  ["roomlp", "rlp"],
  /**
   * Reverb lowpass frequency at -60dB (in hertz).
   * When this property is changed, the reverb will be recaculated, so only change this sparsely..
   *
   * @name roomdim
   * @synonyms rdim
   * @param {number} frequency between 0 and 20000hz
   * @example
   * s("bd sd [~ bd] sd").room(0.5).rlp(10000).rdim(8000)
   * @example
   * s("bd sd [~ bd] sd").room(0.5).rlp(5000).rdim(400)
   *
   */
  ["roomdim", "rdim"],
  /**
   * Reverb fade time (in seconds).
   * When this property is changed, the reverb will be recaculated, so only change this sparsely..
   *
   * @name roomfade
   * @synonyms rfade
   * @param {number} seconds for the reverb to fade
   * @example
   * s("bd sd [~ bd] sd").room(0.5).rlp(10000).rfade(0.5)
   * @example
   * s("bd sd [~ bd] sd").room(0.5).rlp(5000).rfade(4)
   *
   */
  ["roomfade", "rfade"],
  /**
   * Sets the sample to use as an impulse response for the reverb.
   * @name iresponse
   * @param {string | Pattern} sample to use as an impulse response
   * @synonyms ir
   * @example
   * s("bd sd [~ bd] sd").room(.8).ir("<shaker_large:0 shaker_large:2>")
   *
   */
  [["ir", "i"], "iresponse"],
  /**
   * Sets the room size of the reverb, see `room`.
   * When this property is changed, the reverb will be recaculated, so only change this sparsely..
   *
   * @name roomsize
   * @param {number | Pattern} size between 0 and 10
   * @synonyms rsize, sz, size
   * @example
   * s("bd sd [~ bd] sd").room(.8).rsize(1)
   * @example
   * s("bd sd [~ bd] sd").room(.8).rsize(4)
   *
   */
  // TODO: find out why :
  // s("bd sd [~ bd] sd").room(.8).roomsize("<0 .2 .4 .6 .8 [1,0]>").osc()
  // .. does not work. Is it because room is only one effect?
  ["roomsize", "size", "sz", "rsize"],
  // ['sagogo'],
  // ['sclap'],
  // ['sclaves'],
  // ['scrash'],
  /**
   * Wave shaping distortion. CAUTION: it might get loud
   *
   * @name shape
   * @param {number | Pattern} distortion between 0 and 1
   * @example
   * s("bd sd [~ bd] sd,hh*8").shape("<0 .2 .4 .6 .8>")
   *
   */
  ["shape"],
  /**
   * Dynamics Compressor. The params are `compressor("threshold:ratio:knee:attack:release")`
   * More info [here](https://developer.mozilla.org/en-US/docs/Web/API/DynamicsCompressorNode?retiredLocale=de#instance_properties)
   *
   * @name compressor
   * @example
   * s("bd sd [~ bd] sd,hh*8")
   * .compressor("-20:20:10:.002:.02")
   *
   */
  [["compressor", "compressorRatio", "compressorKnee", "compressorAttack", "compressorRelease"]],
  ["compressorKnee"],
  ["compressorRatio"],
  ["compressorAttack"],
  ["compressorRelease"],
  /**
   * Changes the speed of sample playback, i.e. a cheap way of changing pitch.
   *
   * @name speed
   * @param {number | Pattern} speed -inf to inf, negative numbers play the sample backwards.
   * @example
   * s("bd*6").speed("1 2 4 1 -2 -4")
   * @example
   * speed("1 1.5*2 [2 1.1]").s("piano").clip(1)
   *
   */
  ["speed"],
  /**
   * Used in conjunction with `speed`, accepts values of "r" (rate, default behavior), "c" (cycles), or "s" (seconds). Using `unit "c"` means `speed` will be interpreted in units of cycles, e.g. `speed "1"` means samples will be stretched to fill a cycle. Using `unit "s"` means the playback speed will be adjusted so that the duration is the number of seconds specified by `speed`.
   *
   * @name unit
   * @param {number | string | Pattern} unit see description above
   * @example
   * speed("1 2 .5 3").s("bd").unit("c").osc()
   * @superdirtOnly
   *
   */
  ["unit"],
  /**
   * Made by Calum Gunn. Reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter. The SuperCollider manual defines Squiz as:
   *
   * "A simplistic pitch-raising algorithm. It's not meant to sound natural; its sound is reminiscent of some weird mixture of filter, ring-modulator and pitch-shifter, depending on the input. The algorithm works by cutting the signal into fragments (delimited by upwards-going zero-crossings) and squeezing those fragments in the time domain (i.e. simply playing them back faster than they came in), leaving silences inbetween. All the parameters apart from memlen can be modulated."
   *
   * @name squiz
   * @param {number | Pattern} squiz Try passing multiples of 2 to it - 2, 4, 8 etc.
   * @example
   * squiz("2 4/2 6 [8 16]").s("bd").osc()
   * @superdirtOnly
   *
   */
  ["squiz"],
  // ['stutterdepth'], // TODO: what is this? not found in tidal doc
  // ['stuttertime'], // TODO: what is this? not found in tidal doc
  // ['timescale'], // TODO: what is this? not found in tidal doc
  // ['timescalewin'], // TODO: what is this? not found in tidal doc
  // ['tomdecay'],
  // ['vcfegint'],
  // ['vcoegint'],
  // TODO: Use a rest (~) to override the effect <- vowel
  /**
   *
   * Formant filter to make things sound like vowels.
   *
   * @name vowel
   * @param {string | Pattern} vowel You can use a e i o u ae aa oe ue y uh un en an on, corresponding to [a] [e] [i] [o] [u] [æ] [ɑ] [ø] [y] [ɯ] [ʌ] [œ̃] [ɛ̃] [ɑ̃] [ɔ̃]. Aliases: aa = å = ɑ, oe = ø = ö, y = ı, ae = æ.
   * @example
   * note("[c2 <eb2 <g2 g1>>]*2").s('sawtooth')
   * .vowel("<a e i <o u>>")
   * @example
   * s("bd sd mt ht bd [~ cp] ht lt").vowel("[a|e|i|o|u]")
   *
   */
  ["vowel"],
  /* // TODO: find out how it works
   * Made by Calum Gunn. Divides an audio stream into tiny segments, using the signal's zero-crossings as segment boundaries, and discards a fraction of them. Takes a number between 1 and 100, denoted the percentage of segments to drop. The SuperCollider manual describes the Waveloss effect this way:
   *
   * Divide an audio stream into tiny segments, using the signal's zero-crossings as segment boundaries, and discard a fraction of them (i.e. replace them with silence of the same length). The technique was described by Trevor Wishart in a lecture. Parameters: the filter drops drop out of out of chunks. mode can be 1 to drop chunks in a simple deterministic fashion (e.g. always dropping the first 30 out of a set of 40 segments), or 2 to drop chunks randomly but in an appropriate proportion.)
   *
   * mode: ?
   * waveloss: ?
   *
   * @name waveloss
   */
  ["waveloss"],
  /*
   * Noise crackle density
   *
   * @name density
   * @param {number | Pattern} density between 0 and x
   * @example
   * s("crackle*4").density("<0.01 0.04 0.2 0.5>".slow(4))
   *
   */
  ["density"],
  // TODO: midi effects?
  ["dur"],
  // ['modwheel'],
  ["expression"],
  ["sustainpedal"],
  /* // TODO: doesn't seem to do anything
   *
   * Tremolo Audio DSP effect
   *
   * @name tremolodepth
   * @param {number | Pattern} depth between 0 and 1
   * @example
   * n("0,4,7").tremolodepth("<0 .3 .6 .9>").osc()
   *
   */
  ["tremolodepth", "tremdp"],
  ["tremolorate", "tremr"],
  ["fshift"],
  ["fshiftnote"],
  ["fshiftphase"],
  ["triode"],
  ["krush"],
  ["kcutoff"],
  ["octer"],
  ["octersub"],
  ["octersubsub"],
  ["ring"],
  ["ringf"],
  ["ringdf"],
  ["distort"],
  ["freeze"],
  ["xsdelay"],
  ["tsdelay"],
  ["real"],
  ["imag"],
  ["enhance"],
  ["partials"],
  ["comb"],
  ["smear"],
  ["scram"],
  ["binshift"],
  ["hbrick"],
  ["lbrick"],
  ["midichan"],
  ["control"],
  ["ccn"],
  ["ccv"],
  ["polyTouch"],
  ["midibend"],
  ["miditouch"],
  ["ctlNum"],
  ["frameRate"],
  ["frames"],
  ["hours"],
  ["midicmd"],
  ["minutes"],
  ["progNum"],
  ["seconds"],
  ["songPtr"],
  ["uid"],
  ["val"],
  ["cps"],
  /**
   * Multiplies the duration with the given number. Also cuts samples off at the end if they exceed the duration.
   * In tidal, this would be done with legato, [which has a complicated history in strudel](https://github.com/tidalcycles/strudel/issues/111).
   * For now, if you're coming from tidal, just think clip = legato.
   *
   * @name clip
   * @param {number | Pattern} factor >= 0
   * @example
   * note("c a f e").s("piano").clip("<.5 1 2>")
   *
   */
  ["clip"],
  // ZZFX
  ["zrand"],
  ["curve"],
  ["slide"],
  // superdirt duplicate
  ["deltaSlide"],
  ["pitchJump"],
  ["pitchJumpTime"],
  ["lfo", "repeatTime"],
  ["znoise"],
  // noise on the frequency or as bubo calls it "frequency fog" :)
  ["zmod"],
  ["zcrush"],
  // like crush but scaled differently
  ["zdelay"],
  ["tremolo"],
  ["zzfx"]
];
L.createParam = function(e) {
  const t = Array.isArray(e) ? e[0] : e;
  var n;
  Array.isArray(e) ? n = (s) => {
    if (Array.isArray(s)) {
      const i = {};
      return s.forEach((a, u) => {
        u < e.length && (i[e[u]] = a);
      }), i;
    } else
      return { [t]: s };
  } : n = (s) => ({ [t]: s });
  const r = (...s) => R(...s).withValue(n), o = function(...s) {
    return s.length ? this.set(r(...s)) : this.fmap(n);
  };
  return p.prototype[t] = o, r;
};
on.forEach(([e, ...t]) => {
  const n = Array.isArray(e) ? e[0] : e;
  L[n] = L.createParam(e), t.forEach((r) => {
    L[r] = L[n], p.prototype[r] = p.prototype[n];
  });
});
L.createParams = (...e) => e.reduce((t, n) => Object.assign(t, { [n]: L.createParam(n) }), {});
L.adsr = c("adsr", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r, o, s] = e;
  return t.set({ attack: n, decay: r, sustain: o, release: s });
});
L.ad = c("ad", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = n] = e;
  return t.attack(n).decay(r);
});
L.ds = c("ds", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = 0] = e;
  return t.set({ decay: n, sustain: r });
});
L.ds = c("ar", (e, t) => {
  e = Array.isArray(e) ? e : [e];
  const [n, r = n] = e;
  return t.set({ attack: n, release: r });
});
const sn = function(e, t) {
  const [n, r] = e, [o, s] = t, [i, a] = Xt(r, o);
  return [
    [r, n - r],
    [Yt((u, l) => u.concat(l), i, s), a]
  ];
}, cn = function(e, t) {
  const [n, r] = e, [o, s] = t, [i, a] = Xt(n, s);
  return [
    [n, r - n],
    [Yt((l, f) => l.concat(f), o, i), a]
  ];
}, oe = function(e, t) {
  const [n, r] = e;
  return Math.min(n, r) <= 1 ? [e, t] : oe(...n > r ? sn(e, t) : cn(e, t));
}, an = function(e, t) {
  const n = t - e, r = Array(e).fill([1]), o = Array(n).fill([0]), s = oe([e, n], [r, o]);
  return Y(s[1][0]).concat(Y(s[1][1]));
}, Bt = function(e, t, n) {
  const r = an(e, t);
  return n ? Oe(r, -n) : r;
}, es = c("euclid", function(e, t, n) {
  return n.struct(Bt(e, t, 0));
}), { euclidrot: ns, euclidRot: rs } = c(["euclidrot", "euclidRot"], function(e, t, n, r) {
  return r.struct(Bt(e, t, n));
}), se = function(e, t, n, r) {
  if (e < 1)
    return O;
  const s = Bt(e, t, n).join("").split("1").slice(1).map((i) => [i.length + 1, !0]);
  return r.struct(Ct(...s));
}, os = c(["euclidLegato"], function(e, t, n) {
  return se(e, t, 0, n);
}), ss = c(["euclidLegatoRot"], function(e, t, n, r) {
  return se(e, t, n, r);
});
function is(e) {
  return new p((t) => [new T(void 0, t.span, e)]);
}
const nt = (e) => {
  const t = (n) => [new T(void 0, n.span, e(n.span.midpoint()))];
  return new p(t);
}, ie = nt((e) => 1 - e % 1), un = ie.toBipolar(), Tt = nt((e) => e % 1), ln = Tt.toBipolar(), ce = nt((e) => Math.sin(Math.PI * 2 * e)), fn = ce.fromBipolar(), cs = fn._early(b(1).div(4)), as = ce._early(b(1).div(4)), hn = nt((e) => Math.floor(e * 2 % 2)), us = hn.toBipolar(), ls = K(ie, Tt), fs = K(un, ln), pn = nt(lt), dn = (e) => {
  const t = e << 13 ^ e, n = t >> 17 ^ t;
  return n << 5 ^ n;
}, mn = (e) => e - Math.trunc(e), yn = (e) => dn(Math.trunc(mn(e / 300) * 536870912)), wn = (e) => e % 536870912 / 536870912, qt = (e) => Math.abs(wn(yn(e))), hs = (e) => Tt.range(0, e).floor().segment(e), W = nt(qt), ps = W.toBipolar(), ae = (e) => W.fmap((t) => t < e), ds = (e) => d(e).fmap(ae).innerJoin(), ms = ae(0.5), gn = (e) => W.fmap((t) => Math.trunc(t * e)), ys = (e) => d(e).fmap(gn).innerJoin(), bt = function(e, t, n = !0) {
  const r = Array.isArray(e), o = Object.keys(e).length;
  return e = Ie(e, d), o === 0 ? O : t.fmap((s) => {
    let i = s;
    return r && (i = n ? Math.round(i) % o : Me(Math.round(i), 0, e.length - 1)), e[i];
  });
}, bn = function(e, t) {
  return Array.isArray(t) && ([t, e] = [e, t]), vn(e, t);
}, vn = c("pick", function(e, t) {
  return bt(e, t, !1).innerJoin();
}), _n = c("pickmod", function(e, t) {
  return bt(e, t, !0).innerJoin();
}), ws = c("pickF", function(e, t, n) {
  return n.apply(bn(e, t));
}), gs = c("pickmodF", function(e, t, n) {
  return n.apply(_n(e, t));
}), bs = c("inhabit", function(e, t) {
  return bt(e, t, !0).squeezeJoin();
}), vs = c("inhabit", function(e, t) {
  return bt(e, t, !1).squeezeJoin();
}), _s = (e, t) => (t = t.map(d), t.length == 0 ? O : e.fmap((n) => {
  const r = gt(Math.round(n), t.length);
  return t[r];
}).squeezeJoin()), ue = (e, t) => (t = t.map(d), t.length == 0 ? O : e.range(0, t.length).fmap((n) => {
  const r = Math.min(Math.max(Math.floor(n), 0), t.length - 1);
  return t[r];
})), Ot = (e, t) => ue(e, t).outerJoin(), qn = (e, t) => ue(e, t).innerJoin(), qs = (...e) => Ot(W, e);
p.prototype.choose = function(...e) {
  return Ot(this, e);
};
p.prototype.choose2 = function(...e) {
  return Ot(this.fromBipolar(), e);
};
const An = (...e) => qn(W.segment(1), e), As = An, le = function(e, ...t) {
  const n = t.map((a) => d(a[0])), r = [];
  let o = 0;
  for (const a of t)
    o += a[1], r.push(o);
  const s = o, i = function(a) {
    const u = a * s;
    return n[r.findIndex((l) => l > u, r)];
  };
  return e.fmap(i);
}, kn = (...e) => le(...e).outerJoin(), ks = (...e) => kn(W, ...e), Cs = (...e) => le(W, ...e).innerJoin(), Cn = (e) => {
  const t = e.fmap(Math.floor), n = e.fmap((s) => Math.floor(s) + 1), r = (s) => 6 * s ** 5 - 15 * s ** 4 + 10 * s ** 3, o = (s) => (i) => (a) => i + r(s) * (a - i);
  return e.sub(t).fmap(o).appBoth(t.fmap(qt)).appBoth(n.fmap(qt));
}, Ss = Cn(pn.fmap((e) => Number(e))), xs = c(
  "degradeByWith",
  (e, t, n) => n.fmap((r) => (o) => r).appLeft(e.filterValues((r) => r > t))
), Bs = c("degradeBy", function(e, t) {
  return t._degradeByWith(W, e);
}), Ts = c("degrade", (e) => e._degradeBy(0.5)), Os = c("undegradeBy", function(e, t) {
  return t._degradeByWith(
    W.fmap((n) => 1 - n),
    e
  );
}), Es = c("undegrade", (e) => e._undegradeBy(0.5)), zs = c("sometimesBy", function(e, t, n) {
  return d(e).fmap((r) => M(n._degradeBy(r), t(n._undegradeBy(1 - r)))).innerJoin();
}), Ps = c("sometimes", function(e, t) {
  return t._sometimesBy(0.5, e);
}), Ms = c("someCyclesBy", function(e, t, n) {
  return d(e).fmap(
    (r) => M(
      n._degradeByWith(W._segment(1), r),
      t(n._degradeByWith(W.fmap((o) => 1 - o)._segment(1), 1 - r))
    )
  ).innerJoin();
}), js = c("someCycles", function(e, t) {
  return t._someCyclesBy(0.5, e);
}), Fs = c("often", function(e, t) {
  return t.sometimesBy(0.75, e);
}), Ns = c("rarely", function(e, t) {
  return t.sometimesBy(0.25, e);
}), $s = c("almostNever", function(e, t) {
  return t.sometimesBy(0.1, e);
}), Hs = c("almostAlways", function(e, t) {
  return t.sometimesBy(0.9, e);
}), Ls = c("never", function(e, t) {
  return t;
}), Js = c("always", function(e, t) {
  return e(t);
});
let wt;
try {
  wt = window?.speechSynthesis;
} catch {
  console.warn("cannot use window: not in browser?");
}
let Jt = wt?.getVoices();
function Sn(e, t, n) {
  wt.cancel();
  const r = new SpeechSynthesisUtterance(e);
  r.lang = t, Jt = wt.getVoices();
  const o = Jt.filter((s) => s.lang.includes(t));
  typeof n == "number" ? r.voice = o[n % o.length] : typeof n == "string" && (r.voice = o.find((s) => s.name === s)), speechSynthesis.speak(r);
}
const Ws = c("speak", function(e, t, n) {
  return n.onTrigger((r, o) => {
    Sn(o.value, e, t);
  });
}), xn = async (...e) => {
  const t = await Promise.allSettled(e), n = t.filter((r) => r.status === "fulfilled").map((r) => r.value);
  t.forEach((r, o) => {
    r.status === "rejected" && console.warn(`evalScope: module with index ${o} could not be loaded:`, r.reason);
  }), n.forEach((r) => {
    Object.entries(r).forEach(([o, s]) => {
      globalThis[o] = s;
    });
  });
};
function Bn(e, t = {}) {
  const { wrapExpression: n = !0, wrapAsync: r = !0 } = t;
  n && (e = `{${e}}`), r && (e = `(async ()=>${e})()`);
  const o = `"use strict";return (${e})`;
  return Function(o)();
}
const Tn = async (e, t) => {
  let n = {};
  if (t) {
    const s = t(e);
    e = s.output, n = s;
  }
  return { mode: "javascript", pattern: await Bn(e, { wrapExpression: !!t }), meta: n };
};
function On(e, t, n = 0.05, r = 0.1, o = 0.1) {
  let s = 0, i = 0, a = 10 ** 4, u = 0.01;
  const l = (w) => n = w(n);
  o = o || r / 2;
  const f = () => {
    const w = e(), E = w + r + o;
    for (i === 0 && (i = w + u); i < E; )
      i = Math.round(i * a) / a, i >= w && t(i, n, s), i < w && console.log("TOO LATE", i), i += n, s++;
  };
  let h;
  const y = () => {
    m(), f(), h = setInterval(f, r * 1e3);
  }, m = () => h !== void 0 && clearInterval(h);
  return { setDuration: l, start: y, stop: () => {
    s = 0, i = 0, m();
  }, pause: () => m(), duration: n, interval: r, getPhase: () => i, minLatency: u };
}
class En {
  constructor({ interval: t, onTrigger: n, onToggle: r, onError: o, getTime: s, latency: i = 0.1 }) {
    this.started = !1, this.cps = 0.5, this.num_ticks_since_cps_change = 0, this.lastTick = 0, this.lastBegin = 0, this.lastEnd = 0, this.getTime = s, this.num_cycles_since_last_cps_change = 0, this.onToggle = r, this.latency = i, this.clock = On(
      s,
      // called slightly before each cycle
      (a, u, l) => {
        l === 0 && (this.origin = a), this.num_ticks_since_cps_change === 0 && (this.num_cycles_since_last_cps_change = this.lastEnd), this.num_ticks_since_cps_change++;
        try {
          const f = s(), h = this.lastEnd;
          this.lastBegin = h;
          const y = u * this.cps, m = this.num_cycles_since_last_cps_change + this.num_ticks_since_cps_change * y;
          this.lastEnd = m;
          const A = this.pattern.queryArc(h, m, { _cps: this.cps }), v = a - f;
          this.lastTick = f + v, A.forEach((q) => {
            if (q.part.begin.equals(q.whole.begin)) {
              const w = (q.whole.begin - h) / this.cps + v + i, E = q.duration / this.cps;
              n?.(q, w, E, this.cps);
            }
          });
        } catch (f) {
          H(`[cyclist] error: ${f.message}`), o?.(f);
        }
      },
      t
      // duration of each cycle
    );
  }
  now() {
    const t = this.getTime() - this.lastTick - this.clock.duration;
    return this.lastBegin + t * this.cps;
  }
  setStarted(t) {
    this.started = t, this.onToggle?.(t);
  }
  start() {
    if (this.num_ticks_since_cps_change = 0, this.num_cycles_since_last_cps_change = 0, !this.pattern)
      throw new Error("Scheduler: no pattern set! call .setPattern first.");
    H("[cyclist] start"), this.clock.start(), this.setStarted(!0);
  }
  pause() {
    H("[cyclist] pause"), this.clock.pause(), this.setStarted(!1);
  }
  stop() {
    H("[cyclist] stop"), this.clock.stop(), this.lastEnd = 0, this.setStarted(!1);
  }
  setPattern(t, n = !1) {
    this.pattern = t, n && !this.started && this.start();
  }
  setCps(t = 0.5) {
    this.cps !== t && (this.cps = t, this.num_ticks_since_cps_change = 0);
  }
  log(t, n, r) {
    const o = r.filter((s) => s.hasOnset());
    console.log(`${t.toFixed(4)} - ${n.toFixed(4)} ${Array(o.length).fill("I").join("")}`);
  }
}
let At;
function fe() {
  if (!At)
    throw new Error("no time set! use setTime to define a time source");
  return At();
}
function zn(e) {
  At = e;
}
function Is({
  interval: e,
  defaultOutput: t,
  onSchedulerError: n,
  onEvalError: r,
  beforeEval: o,
  afterEval: s,
  getTime: i,
  transpiler: a,
  onToggle: u,
  editPattern: l,
  onUpdateState: f
}) {
  const h = {
    schedulerError: void 0,
    evalError: void 0,
    code: "// LOADING",
    activeCode: "// LOADING",
    pattern: void 0,
    miniLocations: [],
    widgets: [],
    pending: !1,
    started: !1
  }, y = (g) => {
    Object.assign(h, g), h.isDirty = h.code !== h.activeCode, h.error = h.evalError || h.schedulerError, f?.(h);
  }, m = new En({
    interval: e,
    onTrigger: Pn({ defaultOutput: t, getTime: i }),
    onError: n,
    getTime: i,
    onToggle: (g) => {
      y({ started: g }), u?.(g);
    }
  });
  let A = {}, v;
  const q = function() {
    return A = {}, v = void 0, O;
  }, w = (g, C = !0) => {
    g = l?.(g) || g, m.setPattern(g, C);
  };
  zn(() => m.now());
  const E = () => m.stop(), N = () => m.start(), D = () => m.pause(), Q = () => m.toggle(), I = (g) => m.setCps(g), X = (g) => m.setCps(g / 60), rt = function(g) {
    return v = g, O;
  }, ot = () => {
    p.prototype.p = function(C) {
      return A[C] = this, this;
    }, p.prototype.q = function(C) {
      return O;
    };
    try {
      for (let C = 1; C < 10; ++C)
        Object.defineProperty(p.prototype, `d${C}`, {
          get() {
            return this.p(C);
          },
          configurable: !0
        }), Object.defineProperty(p.prototype, `p${C}`, {
          get() {
            return this.p(C);
          },
          configurable: !0
        }), p.prototype[`q${C}`] = O;
    } catch (C) {
      console.warn("injectPatternMethods: error:", C);
    }
    const g = c("cpm", function(C, G) {
      return G._fast(C / 60 / m.cps);
    });
    xn({
      all: rt,
      hush: q,
      cpm: g,
      setCps: I,
      setcps: I,
      setCpm: X,
      setcpm: X
    });
  };
  return { scheduler: m, evaluate: async (g, C = !0, G = !0) => {
    if (!g)
      throw new Error("no code to evaluate");
    try {
      y({ code: g, pending: !0 }), ot(), await o?.({ code: g }), G && q();
      let { pattern: B, meta: P } = await Tn(g, a);
      if (Object.keys(A).length && (B = M(...Object.values(A))), v && (B = v(B)), !Zt(B)) {
        const Z = `got "${typeof evaluated}" instead of pattern`;
        throw new Error(Z + (typeof evaluated == "function" ? ", did you forget to call a function?" : "."));
      }
      return H("[eval] code updated"), w(B, C), y({
        miniLocations: P?.miniLocations || [],
        widgets: P?.widgets || [],
        activeCode: g,
        pattern: B,
        evalError: void 0,
        schedulerError: void 0,
        pending: !1
      }), s?.({ code: g, pattern: B, meta: P }), B;
    } catch (B) {
      H(`[eval] error: ${B.message}`, "error"), y({ evalError: B, pending: !1 }), r?.(B);
    }
  }, start: N, stop: E, pause: D, setCps: I, setPattern: w, setCode: (g) => y({ code: g }), toggle: Q, state: h };
}
const Pn = ({ getTime: e, defaultOutput: t }) => async (n, r, o, s) => {
  try {
    (!n.context.onTrigger || !n.context.dominantTrigger) && await t(n, r, o, s), n.context.onTrigger && await n.context.onTrigger(e() + r, n, e(), s);
  } catch (i) {
    H(`[cyclist] error: ${i.message}`, "error");
  }
}, Et = (e = "test-canvas") => {
  let t = document.querySelector("#" + e);
  if (!t) {
    t = document.createElement("canvas"), t.id = e, t.width = window.innerWidth * 2, t.height = window.innerHeight * 2, t.style = "pointer-events:none;width:100%;height:100%;position:fixed;top:0;left:0", document.body.prepend(t);
    let r;
    window.addEventListener("resize", () => {
      r && clearTimeout(r), r = setTimeout(() => {
        t.width = window.innerWidth * 2, t.height = window.innerHeight * 2;
      }, 200);
    });
  }
  return t.getContext("2d");
};
p.prototype.draw = function(e, { from: t, to: n, onQuery: r } = {}) {
  if (typeof window > "u")
    return this;
  window.strudelAnimation && cancelAnimationFrame(window.strudelAnimation);
  const o = Et();
  let s, i = [];
  const a = (u) => {
    const l = fe();
    if (t !== void 0 && n !== void 0) {
      const f = Math.floor(l);
      if (s !== f) {
        s = f;
        const h = f + t, y = f + n;
        setTimeout(() => {
          i = this.query(new et(new x(h, y))).filter(Boolean).filter((m) => m.part.begin.equals(m.whole.begin)), r?.(i);
        }, 0);
      }
    }
    e(o, i, l, u), window.strudelAnimation = requestAnimationFrame(a);
  };
  return requestAnimationFrame(a), this;
};
const Rs = (e = !0) => {
  const t = Et();
  e && t.clearRect(0, 0, t.canvas.width, t.canvas.width), window.strudelAnimation && cancelAnimationFrame(window.strudelAnimation), window.strudelScheduler && clearInterval(window.strudelScheduler);
};
p.prototype.onPaint = function(e) {
  return this.context = { onPaint: e }, this;
};
class Mn {
  constructor(t, n) {
    this.onFrame = t, this.onError = n;
  }
  start() {
    const t = this;
    let n = requestAnimationFrame(function r(o) {
      try {
        t.onFrame(o);
      } catch (s) {
        t.onError(s);
      }
      n = requestAnimationFrame(r);
    });
    t.cancel = () => {
      cancelAnimationFrame(n);
    };
  }
  stop() {
    this.cancel && this.cancel();
  }
}
class Vs {
  constructor(t, n) {
    this.visibleHaps = [], this.lastFrame = null, this.drawTime = n, this.framer = new Mn(
      () => {
        if (!this.scheduler) {
          console.warn("Drawer: no scheduler");
          return;
        }
        const r = Math.abs(this.drawTime[0]), o = this.drawTime[1], s = this.scheduler.now() + o;
        if (this.lastFrame === null) {
          this.lastFrame = s;
          return;
        }
        const i = this.scheduler.pattern.queryArc(Math.max(this.lastFrame, s - 1 / 10), s);
        this.lastFrame = s, this.visibleHaps = (this.visibleHaps || []).filter((u) => u.whole?.end >= s - r - o).concat(i.filter((u) => u.hasOnset()));
        const a = s - o;
        t(this.visibleHaps, a, this);
      },
      (r) => {
        console.warn("draw error", r);
      }
    );
  }
  setDrawTime(t) {
    this.drawTime = t;
  }
  invalidate(t = this.scheduler, n) {
    if (!t)
      return;
    n = n ?? t.now(), this.scheduler = t;
    let [r, o] = this.drawTime;
    const [s, i] = [Math.max(n, 0), n + o + 0.1];
    this.visibleHaps = this.visibleHaps.filter((u) => u.whole.begin < n);
    const a = t.pattern.queryArc(s, i);
    this.visibleHaps = this.visibleHaps.concat(a);
  }
  start(t) {
    this.scheduler = t, this.invalidate(), this.framer.start();
  }
  stop() {
    this.framer && this.framer.stop();
  }
}
const { createParams: jn } = L;
let Wt = "#22222210";
p.prototype.animate = function({ callback: e, sync: t = !1, smear: n = 0.5 } = {}) {
  window.frame && cancelAnimationFrame(window.frame);
  const r = Et(), { clientWidth: o, clientHeight: s } = r.canvas;
  let i = n === 0 ? "99" : Number((1 - n) * 100).toFixed(0);
  i = i.length === 1 ? `0${i}` : i, Wt = `#200010${i}`;
  const a = (u) => {
    let l;
    u = Math.round(u), l = this.slow(1e3).queryArc(u, u), r.fillStyle = Wt, r.fillRect(0, 0, o, s), l.forEach((f) => {
      let { x: h, y, w: m, h: A, s: v, r: q, angle: w = 0, fill: E = "darkseagreen" } = f.value;
      if (m *= o, A *= s, q !== void 0 && w !== void 0) {
        const D = w * 2 * Math.PI, [Q, I] = [(o - m) / 2, (s - A) / 2];
        h = Q + Math.cos(D) * q * Q, y = I + Math.sin(D) * q * I;
      } else
        h *= o - m, y *= s - A;
      const N = { ...f.value, x: h, y, w: m, h: A };
      r.fillStyle = E, v === "rect" ? r.fillRect(h, y, m, A) : v === "ellipse" && (r.beginPath(), r.ellipse(h + m / 2, y + A / 2, m / 2, A / 2, 0, 0, 2 * Math.PI), r.fill()), e && e(r, N, f);
    }), window.frame = requestAnimationFrame(a);
  };
  return window.frame = requestAnimationFrame(a), O;
};
const { x: he, y: Ds, w: Gs, h: Qs, angle: Us, r: Ks, fill: Xs, smear: Ys } = jn("x", "y", "w", "h", "angle", "r", "fill", "smear"), Zs = c("rescale", function(e, t) {
  return t.mul(he(e).w(e).y(e).h(e));
}), ti = c("moveXY", function(e, t, n) {
  return n.add(he(e).y(t));
}), ei = c("zoomIn", function(e, t) {
  const n = V(1).sub(e).div(2);
  return t.rescale(e).move(n, n);
}), ut = (e, t, n) => e * (n - t) + t, It = (e) => {
  let { value: t } = e;
  typeof e.value != "object" && (t = { value: t });
  let { note: n, n: r, freq: o, s } = t;
  return o ? Gt(o) : (n = n ?? r, typeof n == "string" ? ht(n) : typeof n == "number" ? n : s ? "_" + s : t);
};
p.prototype.pianoroll = function(e = {}) {
  let { cycles: t = 4, playhead: n = 0.5, overscan: r = 1, hideNegative: o = !1 } = e, s = -t * n, i = t * (1 - n);
  return this.draw(
    (a, u, l) => {
      const f = (h) => (!o || h.whole.begin >= 0) && h.whole.begin <= l + i && h.endClipped >= l + s;
      zt({
        ...e,
        time: l,
        ctx: a,
        haps: u.filter(f)
      });
    },
    {
      from: s - r,
      to: i + r
    }
  ), this;
};
function zt({
  time: e,
  haps: t,
  cycles: n = 4,
  playhead: r = 0.5,
  flipTime: o = 0,
  flipValues: s = 0,
  hideNegative: i = !1,
  // inactive = '#C9E597',
  // inactive = '#FFCA28',
  inactive: a = "#7491D2",
  active: u = "#FFCA28",
  // background = '#2A3236',
  background: l = "transparent",
  smear: f = 0,
  playheadColor: h = "white",
  minMidi: y = 10,
  maxMidi: m = 90,
  autorange: A = 0,
  timeframe: v,
  fold: q = 0,
  vertical: w = 0,
  labels: E = !1,
  fill: N = 1,
  fillActive: D = !1,
  strokeActive: Q = !0,
  stroke: I,
  hideInactive: X = 0,
  colorizeInactive: rt = 1,
  fontFamily: ot,
  ctx: k
} = {}) {
  const $ = k.canvas.width, g = k.canvas.height;
  let C = -n * r, G = n * (1 - r);
  v && (console.warn("timeframe is deprecated! use from/to instead"), C = 0, G = v);
  const B = w ? g : $, P = w ? $ : g;
  let Z = w ? [B, 0] : [0, B];
  const pt = G - C, Pt = w ? [0, P] : [P, 0];
  let dt = m - y + 1, tt = P / dt, mt = [];
  o && Z.reverse(), s && Pt.reverse();
  const { min: de, max: me, values: ye } = t.reduce(
    ({ min: S, max: j, values: st }, it) => {
      const F = It(it);
      return {
        min: F < S ? F : S,
        max: F > j ? F : j,
        values: st.includes(F) ? st : [...st, F]
      };
    },
    { min: 1 / 0, max: -1 / 0, values: [] }
  );
  A && (y = de, m = me, dt = m - y + 1), mt = ye.sort(
    (S, j) => typeof S == "number" && typeof j == "number" ? S - j : typeof S == "number" ? 1 : String(S).localeCompare(String(j))
  ), tt = q ? P / mt.length : P / dt, k.fillStyle = l, k.globalAlpha = 1, f || (k.clearRect(0, 0, $, g), k.fillRect(0, 0, $, g)), t.forEach((S) => {
    const j = S.whole.begin <= e && S.endClipped > e;
    let st = I ?? (Q && j), it = !j && N || j && D;
    if (X && !j)
      return;
    let F = S.value?.color || S.context?.color;
    u = F || u, a = rt && F || a, F = j ? u : a, k.fillStyle = it ? F : "transparent", k.strokeStyle = F, k.globalAlpha = S.context.velocity ?? S.value?.gain ?? 1;
    const we = (S.whole.begin - (o ? G : C)) / pt, Mt = ut(we, ...Z);
    let ct = ut(S.duration / pt, 0, B);
    const jt = It(S), ge = q ? mt.indexOf(jt) / mt.length : (Number(jt) - y) / dt, Ft = ut(ge, ...Pt);
    let Nt = 0;
    const $t = ut(e / pt, ...Z);
    let at;
    if (w ? at = [
      Ft + 1 - (s ? tt : 0),
      // x
      B - $t + Mt + Nt + 1 - (o ? 0 : ct),
      // y
      tt - 2,
      // width
      ct - 2
      // height
    ] : at = [
      Mt - $t + Nt + 1 - (o ? ct : 0),
      // x
      Ft + 1 - (s ? 0 : tt),
      // y
      ct - 2,
      // widith
      tt - 2
      // height
    ], st && k.strokeRect(...at), it && k.fillRect(...at), E) {
      const be = S.value.note ?? S.value.s + (S.value.n ? `:${S.value.n}` : ""), { label: Ht, activeLabel: ve } = S.value, _e = (j && ve || Ht) ?? be;
      let qe = w ? ct : tt * 0.75;
      k.font = `${qe}px ${ot || "monospace"}`, k.fillStyle = /* isActive &&  */
      it ? "black" : F, k.textBaseline = "top", k.fillText(_e, ...at);
    }
  }), k.globalAlpha = 1;
  const yt = ut(-C / pt, ...Z);
  return k.strokeStyle = h, k.beginPath(), w ? (k.moveTo(0, yt), k.lineTo(P, yt)) : (k.moveTo(yt, 0), k.lineTo(yt, P)), k.stroke(), this;
}
function pe(e, t = {}) {
  let [n, r] = e;
  n = Math.abs(n);
  const o = r + n, s = n / o;
  return { fold: 1, ...t, cycles: o, playhead: s };
}
const Fn = (e = {}) => (t, n, r, o, s = {}) => zt({ ctx: t, time: n, haps: r, ...pe(o, { ...s, ...e }) });
p.prototype.punchcard = function(e) {
  return this.onPaint(Fn(e));
};
p.prototype.wordfall = function(e) {
  return this.punchcard({ vertical: 1, labels: 1, stroke: 0, fillActive: 1, active: "white", ...e });
};
function ni(e) {
  const { drawTime: t, ...n } = e;
  zt({ ...pe(t), ...n });
}
function Nn(e, t, n, r) {
  const o = (e - 90) * Math.PI / 180;
  return [n + Math.cos(o) * t, r + Math.sin(o) * t];
}
const Rt = (e, t, n, r, o = 0) => Nn((e + o) * 360, t * e, n, r);
function Vt(e) {
  let {
    ctx: t,
    from: n = 0,
    to: r = 3,
    margin: o = 50,
    cx: s = 100,
    cy: i = 100,
    rotate: a = 0,
    thickness: u = o / 2,
    color: l = "#0000ff30",
    cap: f = "round",
    stretch: h = 1,
    fromOpacity: y = 1,
    toOpacity: m = 1
  } = e;
  n *= h, r *= h, a *= h, t.lineWidth = u, t.lineCap = f, t.strokeStyle = l, t.globalAlpha = y, t.beginPath();
  let [A, v] = Rt(n, o, s, i, a);
  t.moveTo(A, v);
  const q = 1 / 60;
  let w = n;
  for (; w <= r; ) {
    const [E, N] = Rt(w, o, s, i, a);
    t.globalAlpha = (w - n) / (r - n) * m, t.lineTo(E, N), w += q;
  }
  t.stroke();
}
p.prototype.spiral = function(e = {}) {
  const {
    stretch: t = 1,
    size: n = 80,
    thickness: r = n / 2,
    cap: o = "butt",
    // round butt squar,
    inset: s = 3,
    // start angl,
    playheadColor: i = "#ffffff90",
    playheadLength: a = 0.02,
    playheadThickness: u = r,
    padding: l = 0,
    steady: f = 1,
    inactiveColor: h = "#ffffff20",
    colorizeInactive: y = 0,
    fade: m = !0
    // logSpiral = true,
  } = e;
  function A({ ctx: v, time: q, haps: w, drawTime: E }) {
    const [N, D] = [v.canvas.width, v.canvas.height];
    v.clearRect(0, 0, N * 2, D * 2);
    const [Q, I] = [N / 2, D / 2], X = {
      margin: n / t,
      cx: Q,
      cy: I,
      stretch: t,
      cap: o,
      thickness: r
    }, rt = {
      ...X,
      thickness: u,
      from: s - a,
      to: s,
      color: i
    }, [ot] = E, k = f * q;
    w.forEach(($) => {
      const g = $.whole.begin <= q && $.endClipped > q, C = $.whole.begin - q + s, G = $.endClipped - q + s - l, { color: B } = $.context, P = m ? 1 - Math.abs(($.whole.begin - q) / ot) : 1;
      Vt({
        ctx: v,
        ...X,
        from: C,
        to: G,
        rotate: k,
        color: y || g ? B : h,
        fromOpacity: P,
        toOpacity: P
      });
    }), Vt({
      ctx: v,
      ...rt,
      rotate: k
    });
  }
  return this.onPaint((v, q, w, E) => A({ ctx: v, time: q, haps: w, drawTime: E }));
};
function $n(e) {
  window.strudelAnimation && cancelAnimationFrame(window.strudelAnimation);
  const t = (n) => {
    e(n, fe()), window.strudelAnimation = requestAnimationFrame(t);
  };
  requestAnimationFrame(t);
}
const ri = function(e, t = {}) {
  const n = document.getElementById("code"), r = "background-image:url(" + e + ");background-size:contain;";
  n.style = r;
  const { className: o } = n, s = (u, l) => {
    ({
      style: () => n.style = r + ";" + l,
      className: () => n.className = l + " " + o
    })[u]();
  }, i = Object.entries(t).filter(([u, l]) => typeof l == "function");
  Object.entries(t).filter(([u, l]) => typeof l == "string").forEach(([u, l]) => s(u, l)), i.length !== 0 && $n(
    (u, l) => i.forEach(([f, h]) => {
      s(f, h(l));
    })
  );
}, oi = () => {
  const e = document.getElementById("code");
  e && (e.style = "");
};
H("🌀 @strudel/core loaded 🌀");
globalThis._strudelLoaded && console.warn(
  `@strudel/core was loaded more than once...
This might happen when you have multiple versions of strudel installed. 
Please check with "npm ls @strudel/core".`
);
globalThis._strudelLoaded = !0;
export {
  En as Cyclist,
  Vs as Drawer,
  b as Fraction,
  Mn as Framer,
  T as Hap,
  p as Pattern,
  et as State,
  x as TimeSpan,
  ue as __chooseWith,
  ae as _brandBy,
  gn as _irand,
  gt as _mod,
  cr as add,
  Hs as almostAlways,
  $s as almostNever,
  Js as always,
  Sr as and,
  Us as angle,
  ro as apply,
  tr as arrange,
  ri as backgroundImage,
  pr as band,
  We as base64ToUnicode,
  an as bjork,
  yr as blshift,
  dr as bor,
  wo as brak,
  ms as brand,
  ds as brandBy,
  wr as brshift,
  mr as bxor,
  No as bypass,
  ee as cat,
  Er as ceil,
  qs as choose,
  An as chooseCycles,
  qn as chooseInWith,
  Ot as chooseWith,
  Do as chop,
  Po as chunkBack,
  Mo as chunkback,
  Me as clamp,
  Rs as cleanupDraw,
  oi as cleanupUi,
  Xn as code2hash,
  Wo as color,
  Io as colour,
  Gn as compose,
  $r as compress,
  Hr as compressSpan,
  Lr as compressspan,
  Qn as constant,
  L as controls,
  cs as cosine,
  as as cosine2,
  oo as cpm,
  _ as curry,
  Ts as degrade,
  Bs as degradeBy,
  xs as degradeByWith,
  Qr as density,
  lr as div,
  Ve as drawLine,
  ni as drawPianoroll,
  Ho as duration,
  so as early,
  Bo as echo,
  ko as echoWith,
  Co as echowith,
  qr as eq,
  Ar as eqt,
  es as euclid,
  os as euclidLegato,
  ss as euclidLegatoRot,
  rs as euclidRot,
  ns as euclidrot,
  xn as evalScope,
  Tn as evaluate,
  no as every,
  Gr as fast,
  Fo as fastChunk,
  Jr as fastGap,
  K as fastcat,
  jo as fastchunk,
  Wr as fastgap,
  Xs as fill,
  eo as firstOf,
  Xo as fit,
  Y as flatten,
  Or as floor,
  Ir as focus,
  Rr as focusSpan,
  Vr as focusspan,
  Un as fractionalArgs,
  Gt as freqToMidi,
  Pr as fromBipolar,
  Br as func,
  Et as getDrawContext,
  pe as getDrawOptions,
  xe as getFreq,
  Dn as getFrequency,
  Vn as getPlayableNoteValue,
  Fn as getPunchcardPainter,
  Rn as getSoundIndex,
  fe as getTime,
  Pn as getTrigger,
  br as gt,
  _r as gte,
  Qs as h,
  Yn as hash2code,
  Jo as hsl,
  Lo as hsla,
  Ur as hurry,
  lt as id,
  bs as inhabit,
  vs as inhabitmod,
  Yr as inside,
  po as inv,
  ho as invert,
  ys as irand,
  kt as isNote,
  Jn as isNoteWithOctave,
  Zt as isPattern,
  ie as isaw,
  un as isaw2,
  Oo as iter,
  Eo as iterBack,
  zo as iterback,
  Ao as jux,
  _o as juxBy,
  qo as juxby,
  sr as keep,
  ir as keepif,
  to as lastOf,
  io as late,
  Vo as legato,
  lo as linger,
  Qt as listRange,
  Dt as logKey,
  H as logger,
  Uo as loopAt,
  Yo as loopAtCps,
  Ko as loopat,
  Zo as loopatcps,
  gr as lt,
  vr as lte,
  Kt as mapArgs,
  er as mask,
  In as midi2note,
  ft as midiToFreq,
  fr as mod,
  ti as moveXY,
  ur as mul,
  Te as nanFallback,
  kr as ne,
  Cr as net,
  Ls as never,
  ht as noteToMidi,
  J as numeralArgs,
  Ie as objectMap,
  yo as off,
  Fs as often,
  xr as or,
  Zr as outside,
  vo as palindrome,
  Pe as parseFractional,
  Ut as parseNumeral,
  Ss as perlin,
  Cn as perlinWith,
  zt as pianoroll,
  bn as pick,
  ws as pickF,
  _n as pickmod,
  gs as pickmodF,
  Ee as pipe,
  Dr as ply,
  Xe as pm,
  ne as polymeter,
  Ze as polymeterSteps,
  Ue as polyrhythm,
  hr as pow,
  Ke as pr,
  bo as press,
  go as pressBy,
  V as pure,
  Ks as r,
  W as rand,
  ps as rand2,
  As as randcat,
  Mr as range,
  Fr as range2,
  jr as rangex,
  Ns as rarely,
  Nr as ratio,
  ts as ref,
  c as register,
  d as reify,
  ze as removeUndefineds,
  Is as repl,
  Zs as rescale,
  tn as rev,
  $o as ribbon,
  Oe as rotate,
  Tr as round,
  hs as run,
  Tt as saw,
  ln as saw2,
  fo as segment,
  Ye as seq,
  R as sequence,
  or as set,
  Zn as setStringParser,
  zn as setTime,
  nt as signal,
  O as silence,
  fn as sine,
  ce as sine2,
  nn as slice,
  Kr as slow,
  U as slowcat,
  te as slowcatPrime,
  Ys as smear,
  Kn as sol2note,
  js as someCycles,
  Ms as someCyclesBy,
  Ps as sometimes,
  zs as sometimesBy,
  Xr as sparsity,
  Ws as speak,
  Qo as splice,
  Xt as splitAt,
  hn as square,
  us as square2,
  _s as squeeze,
  M as stack,
  is as steady,
  Go as striate,
  nr as struct,
  To as stut,
  So as stutWith,
  xo as stutwith,
  ar as sub,
  rr as superimpose,
  pn as time,
  Ct as timeCat,
  zr as toBipolar,
  ke as tokenizeNote,
  ls as tri,
  fs as tri2,
  Es as undegrade,
  Os as undegradeBy,
  Je as unicodeToBase64,
  Wn as valueToMidi,
  Ro as velocity,
  Gs as w,
  ks as wchoose,
  Cs as wchooseCycles,
  mo as when,
  he as x,
  rn as xfade,
  Ds as y,
  Yt as zipWith,
  co as zoom,
  ao as zoomArc,
  ei as zoomIn,
  uo as zoomarc
};
